#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <functional>

using namespace std;



bool vcmp(vector<int> a, vector<int> b)
{
    if(a.empty() || b.empty())return 0;
    return a[0]<b[0];    
}

template<class T>
class ccmp{
    public:
    bool operator()(T& a, T& b)
    {
        return a[0]>b[0];
        //大于号建立的是小顶堆
    }
};


function<bool(vector<int>, vector<int>)> cmp = vcmp;

int main()
{
    int n;
    cin>>n;
    vector<int> target(n+1, 0);
    vector<int> killedTimes(n+1, 0);
    vector<int> died(n+1, 0);
    


    for(int i = 1; i<=n; i++)
    {
        cin>>target[i];
        if(i == target[i])
            died[i] = 1;
        killedTimes[target[i]]++;
    }

    priority_queue<vector<int>, vector<vector<int>>, ccmp<vector<int>>>mq;

    for(int i = 1; i<=n; i++)
    {
        mq.push({killedTimes[i], i});
        //队列中如果不存在killTimes == 0 的情况
            //1.全部自己杀自己
            //2.除了自杀的人其他全部组成闭环
        //队列中如果存在killTimes == 0 的情况
            //应该先杀掉killTimes等于0的这样然后拯救一批，
            //再继续下去就能拯救最多的人
    }


    while(!mq.empty())
    {
        int firstFireId = mq.top()[1];//找到应该第一个开枪的人
        mq.pop();
        if(died[firstFireId])continue;//如果这个人死了
        if( !died[ target[firstFireId] ] )
        { 
            died[ target[firstFireId] ] = 1;
            int nextTarget = target[ target[firstFireId] ];
            killedTimes[ nextTarget ]--;
            mq.push({killedTimes[nextTarget], nextTarget});
            //将被救，且可能会活下去的人加入重新加入队列中，会拍到老数据的前面，提前died老数据不会影响
        }

    }
    int maxLives = 0;
    for(int i = 1; i<=n; i++)
    {
        if(died[i] == 0)
            maxLives++;
    }

    

    //开始计算最小的存活人数
    //计算思路：
        //1.环0只能存活下来一个人
        //2.环6只能存活下来一个人
        //3.如果不是一个环就是一条线指向了一个自杀的人
        //4.自杀的人必须死
    //所以最终的问题变成了找环的问题

    for(int i = 1; i<=n; i++)died[i] = false;
    vector<int> ringRecorder(n+1,0);
    for(int i = 1; i<=n; i++)ringRecorder[i] = i;
    //处理自杀的人
    for(int i = 1; i<=n; i++)died[i] = (target[i] == i);
    
    //当前的环记录者是自己指向自己，表示单个结点就是一个环，
    //i表示自己的结点，ringRecorder[i]表示i所属的环的根结点

    for(int i = 1; i<=n; i++)
    {
        int firstFirePerson = i;
        if(died[firstFirePerson])continue;

        //firstFirePerson并没有死
        //开始找连接的0 6 和直线环
        int personGotShot = target[firstFirePerson];
        while(!died[personGotShot] && personGotShot != firstFirePerson)
        {
            died[personGotShot] = true;
            personGotShot = target[personGotShot];
        }

        //如果是一个环
        if(personGotShot == firstFirePerson)
        {
            //这里连接成了一个环,但是不知道这个环是0环还是6环，但是我们先改变ringRecorder
            //将环内的所有的结点指向正确的根结点firstFirePerson;
            int fristFirePersonC = firstFirePerson;
            do{
                ringRecorder[fristFirePersonC] = firstFirePerson;
                fristFirePersonC = target[fristFirePersonC];
            }while(fristFirePersonC != firstFirePerson);
        }

        //是一条直线，但是这条直线的终点不同可能会导致不同的结果
        if(ringRecorder[personGotShot]  != personGotShot)
        {
            //这行代码解决的是
            //为了解决visio中的情况，首先遍历到一个0环
            //结果不是0环而是6字型的，而且从6的头部入环时，走的并不是环的根
            //而整个6字环只能存活下来一个
            //但是如果这条直线的终点不是一个环而是一个自杀的人，那么这个直线的起点的人就不能死亡
            died[ringRecorder[personGotShot]] = true;
        }


    }
    int minLives = 0;
    for(int i = 1; i<=n; i++)
    {
        if(died[i] == 0)
            minLives++;
    }

    
    cout<<minLives<<endl;
    cout<<maxLives<<endl;

    return 0;
}


/*
    数据：
    1000 770 349 356 377 888 214 330 941 677 938 471 275 282 60 15 280 17 18 366 273 214 285 23 351 337 205 267 894 808 256 808 976 475 799 129 355 504 589 39 401 397 932 458 459 875 576 47 772 49 555 463 432 900 486 954 175 57 670 930 946 972 673 971 215 699 22 67 953 943 965 482 605 415 950 182 667 672 323 656 525 19 636 976 972 534 97 884 862 467 776 618 228 295 651 602 9 398 681 452 881 634 237 266 205 731 295 659 963 257 987 792 197 853 839 216 407 534 503 280 678 696 482 26 975 938 723 354 119 979 432 352 871 735 887 199 463 315 569 760 808 400 9 73 751 739 659 901 896 183 941 162 830 107 459 30 168 54 446 397 222 547 549 864 704 576 588 123 369 169 170 316 834 548 174 377 69 455 9 871 623 850 182 149 97 984 322 812 976 836 436 763 579 691 143 83 894 193 505 98 546 250 612 57 965 104 737 644 833 379 309 448 753 301 219 367 93 714 612 214 707 181 733 621 765 225 698 124 240 375 94 900 309 440 701 452 5 812 405 451 747 814 72 943 632 151 477 85 548 250 485 251 323 313 974 205 812 551 518 873 473 398 406 835 831 732 581 714 756 507 250 229 736 273 746 710 923 449 478 290 697 644 126 538 349 333 286 129 710 374 357 490 217 814 910 468 424 426 296 504 939 302 831 803 228 565 554 123 745 944 823 899 650 770 475 276 171 317 49 319 851 835 439 855 880 42 684 329 800 362 765 748 463 163 609 443 143 894 669 339 926 858 976 11 190 175 895 805 348 777 863 843 653 374 336 21 175 99 650 78 892 315 644 646 998 902 970 739 275 419 370 302 435 415 374 229 519 175 413 149 190 381 43 888 447 176 366 646 457 953 924 706 392 16 70 346 170 154 261 263 199 77 753 139 827 767 129 52 864 323 780 411 760 413 745 44 541 769 601 156 983 912 853 582 244 947 813 920 403 568 314 90 577 74 433 316 826 64 909 656 232 420 700 421 735 109 158 858 497 469 281 344 799 846 817 501 415 412 208 415 563 412 255 396 296 326 683 450 468 234 52 876 57 129 731 475 664 538 291 270 174 497 608 582 948 250 910 193 488 370 490 309 296 545 35 741 885 448 656 770 549 345 223 957 995 532 318 507 959 780 30 425 29 203 782 510 938 57 637 23 744 881 209 991 853 330 524 778 418 961 883 758 862 837 725 560 579 63 283 847 942 839 542 701 167 685 392 249 57 144 602 769 582 749 452 469 903 654 309 559 434 889 971 513 72 904 964 479 418 634 393 582 58 614 602 836 149 470 939 368 449 660 881 699 301 30 697 68 864 635 590 862 721 881 504 17 596 693 374 384 884 924 574 795 130 526 391 328 235 57 555 400 596 149 884 859 380 75 659 410 519 98 626 623 128 705 630 934 858 14 270 890 420 130 569 635 692 631 491 616 825 199 46 292 307 264 646 674 299 147 283 554 342 373 230 231 656 203 911 471 631 340 282 260 898 28 991 217 506 478 16 582 672 68 76 65 211 858 120 380 187 621 435 214 326 267 163 625 383 596 783 893 282 780 139 512 289 119 255 378 700 277 755 533 328 286 382 614 340 868 811 582 51 825 267 673 725 288 262 573 291 790 18 418 799 237 637 390 939 669 530 474 210 121 904 481 939 608 2 969 825 218 44 800 252 506 678 612 144 102 501 748 477 199 813 702 700 376 221 384 694 517 267 3 486 971 951 218 971 551 1 41 701 198 425 491 182 798 752 809 831 214 194 891 51 902 613 287 79 674 754 268 590 428 794 945 428 697 777 290 702 837 212 87 483 571 106 807 808 96 812 98 815 754 200 534 134 739 470 564 537 702 337 934 585 632 436 318 958 896 846 619 439 606 142 3 370 351 939 844 574 546 496 843 25 33 365 33 394 922 635 349 474 701 752 539 215 303 96 289 38 835 398 600 22 367 396 442 449 882 613 139 664 226 296 318 876 426 274 871 119 678 824 688 857 842 903 512 14 12 918 631 360 105 465 267 965 38 858 601 809 223 269 916 589 602 904 29 379 660 788 835 523 838 681 979 556 583 891 289 30 229 392 593 601 6 990 221 120 470 457 309 592 422 344 875 843 847 547 444 839 862 798 75 798 795 672 947 160 646 434 931 911 358 11 937 400 922 563 40 19 524 553 54 347 39 748 20 786 817 302 537 413 44 170 675 342 847 338 287 444 330 346 18 377 295 997 88 440 410 550 165 862 570 619 932 663 164 23 532 99
    结果：400 555
 */


