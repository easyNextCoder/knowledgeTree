package xformat

import "fmt"

/*
	占位符：

[一般]

　　%v	相应值的默认格式。在打印结构体时，“加号”标记（%+v）会添加字段名

　　%#v	相应值的 Go 语法表示

　　%T	相应值的类型的 Go 语法表示

　　%%	字面上的百分号，并非值的占位符

[布尔]

　　%t	单词 true 或 false。

[整数]

　　%b	二进制表示

　　%c	相应 Unicode 码点所表示的字符

　　%d	十进制表示

　　%o	八进制表示

　　%q	单引号围绕的字符字面值，由 Go 语法安全地转义

　　%x	十六进制表示，字母形式为小写 a-f

　　%X	十六进制表示，字母形式为大写 A-F

　　%U	Unicode 格式：U+1234，等同于 "U+%04X"

[浮点数及其复合构成]

　　%b	无小数部分的，指数为二的幂的科学计数法，与 strconv.FormatFloat 的 'b' 转换格式一致。例如 -123456p-78

　　%e	科学计数法，例如 -1234.456e+78

　　%E	科学计数法，例如 -1234.456E+78

　　%f	有小数点而无指数，例如 123.456

　　%g	根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的 0）输出

　　%G	根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的 0）输出

[字符串与字节切片]

　　%s	字符串或切片的无解译字节

　　%q	双引号围绕的字符串，由 Go 语法安全地转义

　　%x	十六进制，小写字母，每字节两个字符

　　%X	十六进制，大写字母，每字节两个字符

[指针]

　　%p	十六进制表示，前缀 0x

[注意]

　　这里没有 'u' 标记。若整数为无符号类型，他们就会被打印成无符号的。类似地， 这里也不需要指定操作数的大小（int8，int64）。
*/

func precisionControl() {
	fmt.Printf("%08.3f\n", 13.25) //0013.250 //8表示算上小数点一共8位，0表示整数部分不足的前面补0
	fmt.Printf("%8.3f\n", 13.25)  //13.250 //8前面省略0表示整数部分不足的不再补0
	fmt.Printf("%07.3f\n", 13.25)
	fmt.Printf("%7.3f\n", 13.25)
	fmt.Printf("%07.3f\n", 0.25) //000.250
	fmt.Printf("%7.3f\n", 0.25)  //0.250

	fmt.Printf("%07.3f\n", 1378787878.25)
	fmt.Printf("%07.3f\n", 13.25324143141443)
	fmt.Printf("%07.3f\n", 1378787878.25898989899) //整数位超出限定长度仍然打印出来，小数位超出3的限制则会截断

	fmt.Printf("%7.3f\n", 1378787878.25)
	fmt.Printf("%7.3f\n", 13.25324143141443)
	fmt.Printf("%7.3f\n", 1378787878.25898989899)

	fmt.Printf("%.5d\n", 13)                  //前面会补0补足5位
	fmt.Printf("%.5d\n", 133455666)           //超出的会正常打印出正确值
	fmt.Printf("%.5f\n", float64(13))         //13.00000
	fmt.Printf("%.5f\n", float64(1343343434)) //1343343434.00000

}
