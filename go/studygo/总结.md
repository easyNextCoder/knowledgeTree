# const
```go

const (
	X = iota
	Y = iota
	YY
	Z = iota
	ZA
	ZB = 100
	ZC = iota
	ZZ
	ZZZ = iota
)

func IotaWork() {
	fmt.Println(X, Y, YY, Z, ZA, ZB, ZC, ZZ, ZZZ)
	//0 1 2 3 4 100 6 7 8
}
```

# array
```go
func arrAssignWork() {
	a := [3]int{1, 2, 3}
	b := a
	fmt.Printf("a %p %v\n", &a, a)
	fmt.Printf("b %p %v\n", &b, b)//直接发生了内容的复制，二者地址不同，指向不同的内存块，
}
```
# slice
## 定义slice
```go
var x []int //可以直接使用
x := []int{}//可以直接使用
x := make([]int, 10)
var x []int = []int{}
```

## 函数传递slice

```go

func appendOri(ori []int){
     ori[1] = 5//函数内数组改变，原数组改变
     ori = append(ori, 5)//函数内数组改变，原数组不变
}

func main(){
    var a []int = []int{1,2,3}
    appendOri(a)
}
```

## make
```go
make(arr, 5)//len=5 cap=5
make(arr, 5, 10)//len=5 cap=10
```
## [:]
```go
//情况1：二者指向同一个数组
var a []int = []int{1,2,3,4,5}
b := a[2:]//b与a指向同一块内存，但是b的指向往后移8个字节    

//情况2：扩容前指向同一数组，之后指向不同数组
a := []int{0, 0} //len == caps == 2
b := a[:]
b = append(b, []int{1, 2, 3}...) //append改变了a的长度，因此生成新的数组
fmt.Printf("%d %d %p %p %v\n", len(a), cap(a), a, &a, a)
fmt.Printf("%d %d %p %p %v\n", len(b), cap(b), b, &b, b)
```

## copy
```go
x := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
y := make([]int, 5)//长度必须注明
copy(y, x) 

```

## slice指针

```go
func slicePointerWork(ps *[]int) {
    s := ps
    for i := 0; i < 100; i++ {
        *s = append(*s, 1)//改变了原数组，包括内容，len和cap
    }

}

func slicePointerWork2(ps *[]int) {
    x := []int{1, 2}
    slicePointerWork(&x)
    fmt.Println(x)
}
```

## item in range

在```go for _, item := range arr{}```中item很特殊，item是会重复使用的，因此在迭代过程中取item的地址都是同一个地址
```go


func changeInForRange() {
	var x StructSlice = StructSlice{
		arr: []int{1, 2, 3, 4, 5},
		s:   "yourname",
	}
	var y StructSlice = StructSlice{
		arr: []int{1, 2, 3, 4, 5},
		s:   "myname",
	}

	//迭代过程中，无法通过变量来改变原结构体内容（item发生拷贝）
	var vl []StructSlice = []StructSlice{x, y}
	for _, p := range vl {
		p.s = "xxxxname"              //不会改变
		p.arr[1] = 100                //会发生改变
		p.arr = append(p.arr, 999)    //不会append成功，只对临时变量生效了
		fmt.Printf("临时变量的地址%p\n", &p) //for中迭代的变量只有一个会一只复用
	}
	fmt.Println(vl[0], vl[1])

	//迭代过程中，可以通过指针来改变原结构体内容（item拷贝了之前的指针）
	var sl []*StructSlice = []*StructSlice{&x, &y}
	for _, p := range sl {
		p.s = "xxxxname"           //会发生改变
		p.arr[1] = 100             //会发生改变
		p.arr = append(p.arr, 999) //会append成功，直接通过临时变量操作了原变量
	}
	fmt.Println(sl[0], sl[1])
}

```

```go

type Traverse struct {
	v     [3]int//结构体中的定长的数组，会在迭代过程中，拷贝到临时变量上，通过迭代的变量去改变内容，原内容不发生改变
	b     int//如上
	slice []int//迭代过程中的临时变量储存了slice的结果变量，下标索引更改生效，append不生效
}

func changeRangeItem() {
	var x Traverse = Traverse{
		v:     [3]int{1, 2, 3},
		b:     100,
		slice: []int{9, 8, 7},
	}

	var y Traverse = Traverse{
		v:     [3]int{1, 2, 3},
		b:     100,
		slice: []int{9, 8, 7},
	}

	var s []Traverse = []Traverse{x, y}
	//这样定义变量是以复制的方式进行的，
	//对于slice类型的变量复制了SliceHeader,所以只有改变slice中的内容会改变原被append的变量的内容，均不会改变

	fmt.Printf("变量放入数组之后和之前的地址比较\n x(%p) x.v(%p) x.b(%p) x.slice(%p%p) \n"+
		"s[0](%p) s[0].v(%p) s[0].b(%p) s[0].slice(%p%p) \n"+
		"y(%p) y.v(%p) y.b(%p) y.slice(%p%p)\n"+
		"s[1](%p) s[1].v(%p) s[1].p(%p) s[1].slice(%p%p)\n",
		&x, &x.v, &x.b, x.slice, &x.slice,
		&s[0], &s[0].v, &s[0].b, s[0].slice, &s[0].slice,
		&y, &y.v, &y.b, y.slice, &y.slice,
		&s[1], &s[1].v, &s[1].b, s[1].slice, &s[1].slice)

	var sv []Traverse

	for _, item := range s {
		//每次遍历item会复制s数组中的内容，且item变量会一直被复用
		//item := item //这样写会禁止复用
		item.v[1] = 999     //无法改变s中的值
		item.b = 999        //无法改变s中的值
		item.slice[1] = 999 //可以改变s中的slice的值，但无法改变slice的len和cap
		item.slice = append(item.slice, 999)
		sv = append(sv, item)
		fmt.Printf("遍历时候的中间变量的地址是:%p %v\n", &item, item)
	}

	fmt.Printf("变量放入数组之后和之前的地址比较\n x(%p) x.v(%p) x.b(%p) x.slice(%p%p)\n"+
		"sv[0](%p) sv[0].v(%p) sv[0].b(%p) sv[0].slice(%p%p)\n"+
		"y(%p) y.v(%p) y.b(%p) y.slice(%p%p)\n"+
		"sv[1](%p) sv[1].v(%p) sv[1].p(%p) sv[1].slice(%p%p)\n",
		&x, &x.v, &x.b, x.slice, &x.slice,
		&sv[0], &sv[0].v, &sv[0].b, sv[0].slice, &sv[0].slice,
		&y, &y.v, &y.b, y.slice, &y.slice,
		&sv[1], &sv[1].v, &sv[1].b, sv[1].slice, &sv[1].slice)

	fmt.Println(s)
	fmt.Println(sv)

}

```

# map

## 并发读写panic
```go

func Unsafe_map() {
	c := make(map[string]int)
	go func() { //开一个goroutine写map
		for j := 0; j < 1000000; j++ {
			c[fmt.Sprintf("%d", j)] = j
		}
	}()
	go func() { //开一个goroutine读map
		for j := 0; j < 1000000; j++ {
			fmt.Println(c[fmt.Sprintf("%d", j)])
		}
	}()
	time.Sleep(time.Second * 20)
}

```

## 并发写和删除会panic
```go
func xmapWork() {
	m := make(map[int]int)

	go func() {
		for {
			for i := 0; i < 10; i++ {
				m[i] = 0
			}
		}

	}()

	go func() {
		for {
			for i := 0; i < 10; i++ {
				delete(m, i)
			}
		}

	}()
	time.Sleep(10)
}
```

## 读写锁保证并发安全
```go

type SafeMap struct {
	sync.RWMutex
	m map[string]int
}


func Safe_map() {
	var c = struct {
		sync.RWMutex
		m map[string]int
	}{m: make(map[string]int)}

	go func() { //开一个goroutine写map
		for j := 0; j < 1000000; j++ {
			c.Lock()
			c.m[fmt.Sprintf("%d", j)] = j
			c.Unlock()
		}
	}()
	go func() { //开一个goroutine读map
		for j := 0; j < 1000000; j++ {
			c.RLock()
			fmt.Println(c.m[fmt.Sprintf("%d", j)])
			c.RUnlock()
		}
	}()
	time.Sleep(time.Second * 20)
}

```

## map是个指针，函数外改变内容，原map内容改变
```go


type Proj struct {
	p1 int
	a1 []int
}

type mpAsFuncParamStruct struct {
	mp  map[int]int
	val *Proj
}

func mapAsFuncParam(x *mpAsFuncParamStruct) {
	mp := x.mp
	mp[1] = 1
	mp[2] = 2
	mp[3] = 3
	pp := x.val
	pp.p1 = 1000
}

func mapAsFuncParam1() {
	mp := map[int]int{}
	x := 10

	p := &mpAsFuncParamStruct{
		mp: mp,
		val: &Proj{
			p1: -1,
			a1: []int{1, 2, 3},
		},
	}
	fmt.Println(mp, x, *p.val)
	mapAsFuncParam(p)
	fmt.Println(mp, x, *p.val)
}

```
## 访问map中不存在的key，不会崩溃，返回变量初始化默认值
```go


func mapInit() {
	//wrong code
	boolMap := make(map[int]bool)//返回false
	xr, xv := boolMap[3]
	xt := boolMap[3]
	fmt.Println("访问不存在的key，返回的结果以及格式", xr, xv, xt)

	intMap := map[int]int{}//返回0
	yr, yv := intMap[3]
	yt := intMap[3]
	fmt.Println("int类型map，访问不存在的key，返回的结果以及格式", yr, yv, yt)

	structMap := map[int]struct{}{}//返回empty struct{}
	zr, zv := structMap[3]
	zt := structMap[3]
	fmt.Println("struct类型map，访问不存在的key，返回的结果以及格式", zr, zv, zt)

	structPointerMap := map[int]*struct{}{}//返回nil
	ar, av := structPointerMap[3]
	at := structPointerMap[3]
	fmt.Println("指针类型map，访问不存在的key，返回的结果以及格式", ar, av, at, at == nil)

}
```

## map遍历时删除是安全的且可以完全删除

# lock

## 1. 使用模式
```go


func write(i int) {
	sa.mutex.Lock() //每个锁定都会阻塞后来者，所以必须要进行解锁
	startVal += i
	sa.mutex.Unlock()
}

func mutexWork2() {

	sw := sync.WaitGroup{}
	for i := 0; i < 100; i++ {
		sw.Add(1)
		go func() {
			defer sw.Done()
			//fmt.Println("go1")
			write(1)
		}()
	}
	for i := 0; i < 100; i++ {
		sw.Add(1)
		go func() {
			defer sw.Done()
			//fmt.Println("go2")
			write(-1)
		}()
	}
	sw.Wait()
	fmt.Println(startVal)
}
```

## 2. 无论是mutex还是读写锁，两次lock，或者两次unlock会发生panic

## 3. 一方lock一个资源之后，另一方再去lock，会阻塞住并等待对方释放锁
```go

func WaitLock() {
	var l sync.RWMutex
	sg := sync.WaitGroup{}
	sg.Add(1)
	time.AfterFunc(time.Second*1, func() {

		go func() {
			defer l.Unlock()
			l.Lock()
			fmt.Println("later")
			sg.Done()
		}()
	})

	sg.Add(1)
	go func() {
		defer l.Unlock()
		l.Lock()
		fmt.Println("first sleep")
		time.Sleep(3 * time.Second)
		fmt.Println("first sleep done")
		sg.Done()
	}()

	sg.Wait()
	fmt.Println("final done!")
}
```

## 4. lock和unlock之间的代码一定要尽量的少，防止资源独占造成其他需要该资源的代码产生各种奇怪的崩溃

```go
func (self *sessionAgent) setSession(uid int64, session *Session) {
   self.lock.Lock()

   old := self.sessions[uid]
   if old != nil {
      old.Lasted = false
   }

   self.sessions[uid] = session
   session.Lasted = true

   self.lock.Unlock()//lock和unlock之间的代码足够简短

   self.SocketReplaceHook(session)
}
```

# Goruntines

## 常见的错误
1. 忘记同步协程
   
    funcB的计算是异步的所以res得不到正确结果，所以非要求尽量少开go程 
   ```go
       var a, b int
       
       a = funcA()
       
       go func(){
            b = funcB()
       }()
       
       fmt.Println("res:", a, b)
   ```

3. go程并发读写map
    1. 多go程并发读写单个非map的变量不会panic，但是无法得到预期结果
    2. 多go程并发读写map一定会panic
    3. 多go程

## 协程控制用sync.WaitGroup和context(同步或者取消)
```go

func Rpc(ctx context.Context, url string) error {
	result := make(chan int)
	err := make(chan error)

	go func() {
		// 进行RPC调用，并且返回是否成功，成功通过result传递成功信息，错误通过error传递错误信息
		isSuccess := true

		if RandRange(0, 100) > 50 {
			isSuccess = false
		}

		if isSuccess {
			result <- 1
		} else {
			err <- errors.New("some error happen")
		}
	}()
	
	select {
	case <-ctx.Done():
		// 其他RPC调用调用失败
		fmt.Println("其他rpc 调用失败", ctx.Err())
		return ctx.Err()
	case e := <-err:
		// 本RPC调用失败，返回错误信息
		fmt.Println("本rpc 调用失败", url)
		return e
	case <-result:
		// 本RPC调用成功，不返回错误信息
		fmt.Println("本rpc 调用成功", url)
		return nil

	}
}

func mainWork() {
	ctx, cancel := context.WithCancel(context.Background())

	// RPC1调用
	err := Rpc(ctx, "http://rpc_1_url")
	if err != nil {
		return
	}

	wg := sync.WaitGroup{}

	// RPC2调用
	wg.Add(1)
	go func() {
		defer wg.Done()
		err := Rpc(ctx, "http://rpc_2_url")
		if err != nil {
			cancel()
		}
	}()

	// RPC3调用
	wg.Add(1)
	go func() {
		defer wg.Done()
		err := Rpc(ctx, "http://rpc_3_url")
		if err != nil {
			cancel()
		}
	}()

	// RPC4调用
	wg.Add(1)
	go func() {
		defer wg.Done()
		err := Rpc(ctx, "http://rpc_4_url")
		if err != nil {
			cancel()
		}
	}()

	wg.Wait()

}

```

# interface{}
## 注意点
1. 空指针和空接口不等价
   
    比如返回一个错误指针，但是并不是空的error接口
    ```go
    func returnError() error{
        var p *MyError = nil
        if bad(){
            p = ErrBad
        }     
        return p //will always return a non-nil error.
    }
    ```

    ```go
    
    type EmptyInterfaceNilPointer struct {
    }
    
    func emptyInterfaceNilPointer() {
        var x interface{}
        var y *EmptyInterfaceNilPointer
    
        fmt.Println(x == y)//false
    }
    ```

## 使用interface{}实现多态
1. rsp<-Command
    ```go
    
    type xCommandRsp interface {
        Work()
    }
    
    type xCommandRspChild struct {
        data [10]int
    }
    
    func (xCommandRspChild) Work() {
    
    }
    
    type xFinalRsp struct {
        rsp chan xCommandRsp
    }
    
    func testRsp() {
        v := xFinalRsp{
            rsp: make(chan xCommandRsp),
        }
        go func() {
            val := <-v.rsp
            fmt.Println(val)
        }()
    
        v.rsp <- &xCommandRspChild{data: [10]int{1, 2, 3}}
    
        var cm xCommandRspChild
        cm.Work()
    
    }
    
    ```
## type convert功能
```go
type Cat interface {
    Miao() string
}

type FourFoot interface {
    Work() string
}

type RedCat struct {
    i int
}

func (r RedCat) Miao() string {
    return "RedCat Miao"
}

func (r RedCat) Work() string {
    return "RedCat Work"
}

type RedBigCat struct {
    RedCat
}

type BlueCat struct {
    v int
}

func (r BlueCat) Miao() string {
    return "BlueCat Miao"
}

func playWithCat(cat Cat) {
    //cat.Miao()
    switch cat.(type) {
    case Cat:
        fmt.Println("type is Cat", cat.(FourFoot).Work())
    case FourFoot:
        fmt.Println("type is FourFoot")
    case RedCat:
        fmt.Println("type is RedCat")
    //case *Cat:
    //	fmt.Println("type is *Cat")
    case *RedCat:
        fmt.Println("type is *RedCat", cat.(Cat).Miao())
    case interface{}:
        fmt.Println("type is interface")
    case nil:
        fmt.Println("type is nil")
    default:
        fmt.Println("enter default")
    }
}

func playWithFourFoot(cat FourFoot) {
    //cat.Miao()
    switch cat.(type) {
    case Cat:
        fmt.Println("type is Cat", cat.(FourFoot).Work())
    case FourFoot:
        fmt.Println("type is FourFoot")
    case RedCat:
        fmt.Println("type is RedCat")
    //case *Cat:
    //	fmt.Println("type is *Cat")
    case *RedCat:
        fmt.Println("type is *RedCat", cat.(Cat).Miao())
    case interface{}:
        fmt.Println("type is interface")
    case nil:
        fmt.Println("type is nil")
    default:
        fmt.Println("enter default")
    }
}

func playWithInterface(cat interface{}) {
    //cat.Miao()
    switch cat.(type) {

    case *Cat:
        fmt.Println("type is *Cat")
    case *RedCat:
        fmt.Println("type is *RedCat", cat.(Cat).Miao())
    case Cat:
        fmt.Println("type is Cat", cat.(FourFoot).Work())
    case FourFoot:
        fmt.Println("type is FourFoot")
    case RedCat:
        fmt.Println("type is RedCat")
    case **RedCat:
        fmt.Println("type is **RedCat", (**(cat.(**RedCat))).Miao())
    case nil:
        fmt.Println("type is nil")
    case S:
        fmt.Println("type is S")
    case *S:
        fmt.Println("type is *S")
    case **S:
        fmt.Println("type is **S")
    default:
        fmt.Println("enter default")
    }
}

type S struct {
    int
    float64
    i []int
}

func typeConvertWork() {
    
    var i interface{} = S{}
    var nilCat Cat
    
    //var cat Cat = RedCat{} //值拷贝
    var cat Cat = &RedCat{} //pointer拷贝
    var catP *Cat = &nilCat
    var redCat RedCat
    var redCatP *RedCat = &RedCat{}
    
    fmt.Println("------------------start")
    
    //playWithCat(i)
    //playWithFourFoot(i)
    playWithInterface(i) //type S
    
    //playWithCat(&i)
    //playWithFourFoot(&i)
    playWithInterface(&i) //type *interface{} (取地址操作再赋值给interface{}，会覆盖之前interface中存的类型)
    
    playWithCat(nil)       //type nil
    playWithFourFoot(nil)  //type nil
    playWithInterface(nil) //type nil
    
    playWithCat(nilCat) //type nil
    //playWithFourFoot(nilCat)
    playWithInterface(nilCat) //type nil
    
    playWithCat(cat) //type Cat
    //playWithFourFoot(cat)
    playWithInterface(cat) //type *RedCat
    
    //playWithCat(catP)
    //playWithFourFoot(catP)
    playWithInterface(catP) //input type &(Cat类型的空接口)  type *Cat
    
    //playWithCat(&cat)
    //playWithFourFoot(&cat)
    playWithInterface(&cat) //type *Cat (取地址操作再赋值给interface{}，会覆盖之前interface中存的类型)
    
    playWithCat(redCat)       //type Cat
    playWithFourFoot(redCat)  //type Cat
    playWithInterface(redCat) //type Cat
    
    playWithCat(&redCat)       //自身被赋值给了函数的参数，所以在内部的判断类型是redCat
    playWithFourFoot(&redCat)  //自身被赋值给了函数的参数，所以在内部的判断类型是redCat
    playWithInterface(&redCat) //&redCat即是*redCat类型也是Cat型
    v := &redCat
    playWithInterface(&v) //type **RedCat
    
    playWithCat(redCatP)       //Cat
    playWithFourFoot(redCatP)  //type Cat
    playWithInterface(redCatP) //type *RedCat
    
    var sd S
    var sdp *S
    //playWithCat(S{})
    //playWithFourFoot(S{})
    playWithInterface(S{}) //type S
    
    //playWithCat(sd)
    //playWithFourFoot(sd)
    playWithInterface(sd) //type S
    
    //playWithCat(&sd)
    //playWithFourFoot(&sd)
    playWithInterface(&sd) //type *S
    
    //playWithCat(sdp)
    //playWithFourFoot(sdp)
    playWithInterface(sdp) //type *S
    
    //playWithCat(&sdp)
    //playWithFourFoot(&sdp)
    playWithInterface(&sdp) //type **S
    
    fmt.Println("------------------end")

}
```

# 接口
## 覆盖接口和变量隐藏
```go
    
type notifier interface {
    notify()
    changeValue()
    varChangeValue()
}

type user struct {
    notifier
    name  string
    email string
}

func (u *user) notify() {
    fmt.Println("user.name: ", u.name)
}

func (u *user) changeValue() {
    u.name = u.name + u.name
}

func (u user) varChangeValue() {
    u.email = u.email + u.email
}

type vipUser struct {
    user
    vipScore int
}

func (vu *vipUser) changeValue() {
    vu.name = vu.name + vu.name
}

type admin struct {
    name  string
    email string//以上两个变量不会暴露到外部
}

func (a *admin) notify() {
    fmt.Printf("%p admin notify: %v %v ", a, a.name, a.email)
}

func (a *admin) changeValue() {
    a.name = a.name + a.name
}

func (a admin) varChangeValue() {
    a.email = a.email + a.email
}

func sendNotification(n notifier) {
    n.notify()
}

func changeSelfValue(n notifier) {
    n.changeValue()
}

func varChangeSelfValue(n notifier) {
    n.varChangeValue()
}

func mainWork() {
    bill := user{name: "bill", email: "1234@qq.com"}
    fmt.Printf("%p\n", (&bill))
    fmt.Printf("user.p %p user.notifier %+v user.notifier.p %p\n", &bill, bill.notifier, &(bill.notifier))
    //sendNotification(&bill)
    changeSelfValue(&bill)
    fmt.Println("change bill.name use pointer", bill)

    lisa := admin{name: "lisa", email: "7890@qq.com"}
    fmt.Printf("%p\n", &lisa)
    sendNotification(&lisa)
    varChangeSelfValue(&lisa)
    fmt.Println("change lisa.name use var", lisa)

    bob := vipUser{
        user:     user{name: "bob", email: "6666@qq.com"},
        vipScore: 0,
    }
    bob.notify()
}
```

## 接口实现功能继承与功能组合
```go
    
type Swimmer interface {
    swimming()
}

type Flyer interface {
    fly()
}

type AngryBird struct {
    name string
}

func (a AngryBird) swimming() {
    fmt.Println(a.name, "swimming...")
}

func (a AngryBird) fly() {
    fmt.Println(a.name, "flying...")
}

func swimmerAccepter(s Swimmer) {
    if sFlyer, ok := s.(Flyer); ok {
        sFlyer.fly()
    }
}

type LoveBird struct {
    Swimmer
    Flyer
    tag string
}

func playGround() {

    //多态
    var angryBird1 AngryBird = AngryBird{name: "red"}
    var i interface{} = angryBird1

    if flyer, ok := i.(Flyer); ok {
        flyer.fly()
    }

    if swimmer, ok := i.(Swimmer); ok {
        swimmer.swimming()
    }

    //赋值
    var swimmer Swimmer = AngryBird{name: "blue"}

    swimmerAccepter(swimmer)

    var angryBird AngryBird = AngryBird{name: "angryBird"}

    swimmerAccepter(angryBird) //经过函数参数的时候，会发生类型转换，但是携带的类型信息和变量不会丢失

    //panic
    var loveBird LoveBird

    swimmerAccepter(loveBird) //含有这个类型但是调用没有实现的方法会panic

}
```

# copy

## 1. 在拷贝配置的时候一定要在所有的操作完成之后再赋值，一定要避免先赋值再操作，防止高并发访问的时候预期操作未全部完成而造成的配置不一致问题

```go
func (self *_Sau) SauTransferLimitLoadConf() error {
   if !IsSauBranch() {
      return nil
   }

   conf, err := redis_com.GetUserTransferLimitConf()
   if err != nil {
      niuhe.LogError("SauTransferLimitLoadConf error. err(%s)", err)
      return err
   }
   if conf == nil {
      return nil
   }

   updatedTransferLimitExpMp := map[int]int{
      10: conf.TransferLimitExp10,
      20: conf.TransferLimitExp20,
      30: conf.TransferLimitExp30,
      40: conf.TransferLimitExp40,
      50: conf.TransferLimitExp50,
      60: conf.TransferLimitExp60,
      70: conf.TransferLimitExp70,
      80: conf.TransferLimitExp80,
      90: conf.TransferLimitExp90,
   }
   data.SetVarSauTransferLimitExp(updatedTransferLimitExpMp)

   levelLimitMp := make(map[int64]int64)

   for _, uid := range conf.SpecialLevelLimitUid {
      levelLimitMp[uid] = conf.SpecialLevelLimit
   }

   data.SetVarSauTransferSpUidLevelLimitUid(levelLimitMp, data.TransferLevelLimitIndexSp1)

   levelLimitMp2 := make(map[int64]int64)

   for _, uid := range conf.SpecialLevelLimitUid2 {
      levelLimitMp2[uid] = conf.SpecialLevelLimit2
   }

   data.SetVarSauTransferSpUidLevelLimitUid(levelLimitMp2, data.TransferLevelLimitIndexSp2)

   if len(conf.RankingExcludeIosUsUid) > 20 { //最长支持20个
      conf.RankingExcludeIosUsUid = conf.RankingExcludeIosUsUid[:20]
   }

   sauTransferLimitConf = *conf//对conf操作完之后再赋值给sauTransferLimitConf

   return nil
}
```

# Redis


>参考地址
>
>https://www.cnblogs.com/l-uz/p/16290572.html
> 
>https://blog.csdn.net/Eric_aixiansen/article/details/127777322
> 
>https://pkg.go.dev/github.com/gomodule/redigo/redis
> 
>https://www.cnblogs.com/throwable/p/11644790.html

## redis的通信协议RESP支持的数据类型

RESP支持的数据类型#
RESP在Redis 1.2中引入，在Redis 2.0，RESP正式成为与Redis服务端通信的标准方案。也就是如果需要编写Redis客户端，你就必须在客户端中实现此协议。

RESP本质上是一种序列化协议，它支持的数据类型如下：单行字符串、错误消息、整型数字、定长字符串和RESP数组。

RESP在Redis中用作请求-响应协议的方式如下：

Redis客户端将命令封装为RESP的数组类型（数组元素都是定长字符串类型，注意这一点，很重要）发送到Redis服务器。
Redis服务端根据命令实现选择对应的RESP数据类型之一进行回复。
在RESP中，数据类型取决于数据报的第一个字节：

单行字符串的第一个字节为+。
错误消息的第一个字节为-。
整型数字的第一个字节为:。
定长字符串的第一个字节为$。
RESP数组的第一个字节为*。

## redisgo函数

Executing Commands ¶
The Conn interface has a generic method for executing Redis commands:

```go
    Do(commandName string, args ...interface{}) (reply interface{}, err error)
```
The Redis command reference (http://redis.io/commands) lists the available commands. An example of using the Redis APPEND command is:
```go
    n, err := conn.Do("APPEND", "key", "value")
```

The Do method converts command arguments to bulk strings for transmission to the server as follows:
```go
    Go Type                 Conversion
    []byte                  Sent as is
    string                  Sent as is
    int, int64              strconv.FormatInt(v)
    float64                 strconv.FormatFloat(v, 'g', -1, 64)
    bool                    true -> "1", false -> "0"
    nil                     ""
    all other types         fmt.Fprint(w, v)
```
Redis command reply types are represented using the following Go types:
```go
    Redis type              Go type
    error                   redis.Error
    integer                 int64
    simple string           string
    bulk string             []byte or nil if value not present.
    array                   []interface{} or nil if value not present.
```
Use type assertions or the reply helper functions to convert from interface{} to the specific Go type for the command result.

## redis中的hash的底层数据结构

hash中使用了两种数据结构ziplist和hashtable
当哈希对象可以同时满足以下两个条件时， 哈希对象使用 ziplist 编码：

哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；
* 哈希对象保存的键值对数量小于 512 个；
* 不能满足这两个条件的哈希对象需要使用 hashtable 编码。
>http://redisbook.com/preview/object/hash.html

## redis进程配置信息

#### redis 操作

* 查看redis的运行状态
  **systemctl status redis**

  ```linux
  ● redis-server.service - Advanced key-value store
     Loaded: loaded (/lib/systemd/system/redis-server.service; enabled; vendor preset: enabled)
     Active: active (running) since Thu 2022-07-28 10:44:37 CST; 1 months 24 days ago
       Docs: http://redis.io/documentation,
             man:redis-server(1)
   Main PID: 1247 (redis-server)
      Tasks: 3
     Memory: 219.6M
        CPU: 23h 38min 52.213s
     CGroup: /system.slice/redis-server.service
             └─1247 /usr/bin/redis-server 0.0.0.0:6379         
  
  Warning: Journal has been rotated since unit was started. Log output is incomplete or unavailable.
  
  ```

  通过loaded(xxx)这一行发现redis运行systemctl的配置文件在/lib/systemd/system/redis-server.service，然后

  **cat /lib/systemd/system/redis-server.service**

  ```
  [Unit]
  Description=Advanced key-value store
  After=network.target
  Documentation=http://redis.io/documentation, man:redis-server(1)
  
  [Service]
  Type=forking
  ExecStart=/usr/bin/redis-server /etc/redis/redis.conf
  PIDFile=/var/run/redis/redis-server.pid
  TimeoutStopSec=0
  Restart=always
  User=redis
  Group=redis
  
  xxx
  ```

* 日志文件在：/var/log/redis/redis-server.log
  
* 配置文件在/etc/redis/redis.conf
  redis.conf中的一个配置项：

    * stop-writes-on-bgsave-error yes

## redis操作

1. string
    ```go
    
    func stringOperate() {
        conn := GetRedis()
        defer conn.Close()
    
        //set
        conn.Do(set, "key", 1)
        //get
        do, err := conn.Do(get, "key")
        if err != nil {
            return
        }
        fmt.Println("set", do, string(do.([]byte)))
    
        //setex Redis Setex 命令为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值。
        conn.Do(setex, "setex_key", 3, "setex_val") //3
        do, err = conn.Do(get, "setex_key")
        if err != nil {
            return
        }
        fmt.Println("setex get", do, string(do.([]byte)))
        time.Sleep(time.Second * 3)
        do, err = conn.Do(get, "setex_key")
        if err != nil {
            return
        }
        fmt.Println("setex get after 3s", do, err)
    
        //del
        conn.Do(del, "key")
        do2, err := conn.Do(get, "key")
        if err == redis.ErrNil {
            fmt.Println("redis.ErrNil")
        }
        if err != nil {
            return
        }
        fmt.Println("del", do2)
    
        //incr
        conn.Do(set, "key", "hello1")
        conn.Do(incr, "key")
        val, err := redis.String(conn.Do(get, "key"))
        if err != nil {
            return
        }
        fmt.Println("incr 对字符串，浮点不生效不生效", val)
    
        conn.Do(set, "key", "1")
        conn.Do(incr, "key")
        val2, err := redis.String(conn.Do(get, "key"))
        if err != nil {
            return
        }
        fmt.Println("incr 只对整型的数生效", val2)
    
        //decrby
        conn.Do(del, "key")
        conn.Do(set, "key", "1")
        conn.Do(decrby, "key", 10)
        val3, err := redis.String(conn.Do(get, "key"))
        if err != nil {
            return
        }
        fmt.Println("decrby 能减到负数", val3)
    
        //setnx
        conn.Do(del, "key")
        conn.Do(setnx, "key", "1")
        conn.Do(setnx, "key", "2")
        val4, err := redis.String(conn.Do(get, "key"))
        if err != nil {
            return
        }
        val42, _ := conn.Do(get, "key")
        fmt.Println("setnx 不会发生覆盖", val4, string(val42.([]byte)))
    
        //mset mget
        conn.Do(del, "key")
        conn.Do(mset, "key", "val1", "key2", "val2", "key3", "val3")
        val5, err := redis.Strings(conn.Do(mget, "key", "key2", "key3"))
        if err != nil {
            return
        }
        val52, _ := conn.Do(mget, "key", "key2", "key3")
        fmt.Println("mset mget", val5, string(val52.([]interface{})[2].([]byte)))
    
        //APPEND
        conn.Do(del, "key")
        conn.Do(set, "key", "1")
        conn.Do(APPEND, "key", "1234")
        val6, err := redis.String(conn.Do(get, "key"))
        if err != nil {
            return
        }
        val62, _ := conn.Do(get, "key")
        fmt.Println("append结果", val6, string(val62.([]byte)))
    
        //strlen
        conn.Do(del, "key")
        conn.Do(set, "key", "12345")
        val7, err := redis.Int64(conn.Do(strlen, "key"))
        if err != nil {
            fmt.Println("err", err)
            return
        }
        val72, _ := conn.Do(get, "key")
        fmt.Println("strlen", val7, string(val72.([]byte))) //strlen
    
        //incrbyfloat
        conn.Do(del, "key")
        conn.Do(set, "key", "3.5")
        val8, err := redis.Float64(conn.Do(incrbyfloat, "key", 1.2))
        if err != nil {
            fmt.Println("err", err)
            return
        }
        val82, _ := conn.Do(get, "key")
        fmt.Println("incrbyfloat", val8, string(val82.([]byte)))
    
        //incrbyfloat
        conn.Do(del, "key")
        conn.Do(set, "key", "123456789")
        val9, err := redis.String(conn.Do(getrange, "key", 0, 4))
        if err != nil {
            fmt.Println("err", err)
            return
        }
        fmt.Println("getrange", val9)
    
        //setrange
        conn.Do(del, "key")
        conn.Do(set, "key", "123456789")
        conn.Do(setrange, "key", 3, "hello")
        val10, err := redis.String(conn.Do(get, "key"))
        if err != nil {
            fmt.Println("err", err)
            return
        }
        fmt.Println("setrange", val10)
    
        //scan
        conn.Do("flushall")
        conn.Do("hmset", "key", "field1", "val1") //scan既可以扫描出字符串，对于集合和哈希等一样能够扫描出来
        conn.Do("hmset", "key", "field2", "val2")
        conn.Do("hmset", "key", "field3", "val3")
        conn.Do("sadd", "set", "val1")
        for i := 0; i < 100; i++ {
            conn.Do(set, fmt.Sprintf("key%02d", i), "val"+strconv.Itoa(i))
            conn.Do(set, fmt.Sprintf("name%02d", i), "val"+strconv.Itoa(i))
        }
        var pos int = 0
        var res []string
        scan_(conn, &pos, 10, 30, "name*", &res) //scan的过程中会出现重复，count*n会大于总的key的个数
        sort.StringSlice(res).Sort()
        fmt.Println("scan res:", len(res), res)
    
    }
    
    ```
    ```go
    
    func scan_(i interface{}, pos *int, count int, n int, match string, res *[]string) {
        if n <= 0 {
            return
        }
        conn := i.(redis.Conn)
        //第一次扫描
        val11, err := conn.Do(scan, *pos, "match", match, "count", count)
        if err != nil {
            fmt.Println(err)
        }
        //在这里解析结果
        replies := val11.([]interface{})
        repla1 := replies[0].([]byte)
        repla2 := replies[1].([]interface{})
        repla1final, _ := strconv.Atoi(string(repla1))
        repla2final := make([]string, len(repla2))
        for idx, v := range repla2 {
            repla2final[idx] = string(v.([]byte))
            *res = append(*res, repla2final[idx])
        }
    
        *pos = repla1final
    
        fmt.Println(repla1final, repla2final)
        scan_(conn, pos, count, n-1, match, res)
    
    }
    ```
2. set
    ```go
        
    func setOperate() {
    conn := GetRedis()
    defer conn.Close()
    
        conn.Do(sadd, "set1", "xyk", "xyq", "xyl", "xyz", "xym", "xyu")
        val, _ := redis.Int(conn.Do(scard, "set1"))
        fmt.Println("sadd scard", val)
    
        val2, _ := redis.Bool(conn.Do(sismember, "set1", "xyk"))
        fmt.Println("sismember", val2)
    
        val3, _ := redis.Strings(conn.Do(srandmember, "set1", 2))
        fmt.Println("srandmember", val3)
    
        val4, _ := redis.Strings(conn.Do(smembers, "set1"))
        fmt.Println("smembers", val4)
    
        conn.Do(sadd, "set2", "xyk", "xyq", "xyl", "xyz", "xyv")
    
        val5, _ := redis.Strings(conn.Do(sdiff, "set1", "set2")) //set1-set2得到的结果
        fmt.Println("sdiff", val5)
    
        val7, _ := redis.Strings(conn.Do(sinter, "set1", "set2"))
        fmt.Println("sinter", val7)
    
        val8, _ := redis.Strings(conn.Do(sunion, "set1", "set2"))
        fmt.Println("sunion", val8)
    
        val9, _ := redis.Strings(conn.Do(spop, "set2"))
        val92, _ := redis.Strings(conn.Do(smembers, "set2"))
        fmt.Println("spop", val9, val92)
    
        val10, _ := redis.Strings(conn.Do(srem, "set1", "xyk", "xyq"))
        val102, _ := redis.Strings(conn.Do(smembers, "set1"))
        fmt.Println("srem", val10, val102)
    
        //sscan
        conn.Do("flushall")
        for i := 0; i < 1000; i++ {
            str := xstring.RandString(80)
            k1, _, k2, _ := fmt.Sprintf("key%02d%s", i, str), "val"+strconv.Itoa(i), fmt.Sprintf("name%02d", i), "val"+strconv.Itoa(i)
            conn.Do("sadd", "rootKey", k1)
            conn.Do("sadd", "rootKey", k2)
        }
        var pos int = 0
        var res []string
        xscan_(conn, sscan, "rootKey", &pos, 10, 10, "name*", &res)
        sort.StringSlice(res).Sort()
        fmt.Println("sscan res:", len(res), res)
    
    }
    ```
    
    ```go
    
    func xscan_(i interface{}, cmd, key string, pos *int, count int, n int, match string, res *[]string) {
        if n <= 0 {
            return
        }
        conn := i.(redis.Conn)
        //第一次扫描
        val11, err := conn.Do(cmd, key, *pos, "match", match, "count", count)
        if err != nil {
            fmt.Println(err)
        }
        //在这里解析结果
        replies := val11.([]interface{})
        repla1 := replies[0].([]byte)
        repla2 := replies[1].([]interface{})
        repla1final, _ := strconv.Atoi(string(repla1))
        repla2final := make([]string, len(repla2))
        for idx, v := range repla2 {
            repla2final[idx] = string(v.([]byte))
            *res = append(*res, repla2final[idx])
        }
    
        *pos = repla1final
        fmt.Println(repla1final, repla2final)
        xscan_(conn, cmd, key, pos, count, n-1, match, res)
    }
    ```
   
3. list
    ```go
        
    func listOperate() {
    conn := GetRedis()
    defer conn.Close()
    
        conn.Do(del, "key")
        conn.Do(rpush, "key", "middle", "right")
    
        val, _ := redis.Strings(conn.Do(lrange, "key", 0, 5))
        fmt.Println("rpush", val)
    
        conn.Do(lpush, "key", "left")
        val, _ = redis.Strings(conn.Do(lrange, "key", 0, 5)) //lrange 中-1表示倒数第一个
        fmt.Println("lpush", val)
    
        conn.Do(linsert, "key", "after", "middle", "middle_r")
        val, _ = redis.Strings(conn.Do(lrange, "key", 0, 5))
        fmt.Println("linsert", val)
    
        val, _ = redis.Strings(conn.Do(rpop, "key"))
        fmt.Println("rpop poped", val) //并不会返回值
        val, _ = redis.Strings(conn.Do(lpop, "key"))
        fmt.Println("lpop poped", val) //并不会返回值
        val, _ = redis.Strings(conn.Do(lrange, "key", 0, 5))
        fmt.Println("rpop after pop", val)
    
        //lrem
        conn.Do(del, "key")
        val, _ = redis.Strings(conn.Do(lrange, "key", 0, 5))
        fmt.Println("lrem", val)
        conn.Do(rpush, "key", 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 4, 4)
        val, _ = redis.Strings(conn.Do(lrem, "key", 2, "2")) //向右删除两个
        val, _ = redis.Strings(conn.Do(lrem, "key", 0, "3")) //删除所有的
        val, _ = redis.Strings(conn.Do(lrange, "key", 0, 25))
        fmt.Println("lrem", val)
        val, _ = redis.Strings(conn.Do(lrem, "key", 1, "4"))
        val, _ = redis.Strings(conn.Do(lrem, "key", -2, "4")) //向左删除2个
        val, _ = redis.Strings(conn.Do(lrange, "key", 0, 25))
        fmt.Println("lrem", val)
    
        //ltrim 类似于slice中的[]
        conn.Do(del, "key")
        val, _ = redis.Strings(conn.Do(lrange, "key", 0, 5))
        conn.Do(rpush, "key", 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 4, 4)
        conn.Do(ltrim, "key", 0, 5) //只保留[0,5]下标之间的元素
        val, _ = redis.Strings(conn.Do(lrange, "key", 0, 25))
        fmt.Println("ltrim", val)
    
        conn.Do(del, "key")
        conn.Do(rpush, "key", 1, 1, 2, 2, 3, 3)
        val, _ = redis.Strings(conn.Do(lrange, "key", 0, 5))
        fmt.Println("lindex", val)
        val1, err := redis.String(conn.Do(lindex, "key", 3))
        if err != nil {
            fmt.Println(err)
        }
        fmt.Println("lindex", val1)
    
        conn.Do(del, "key")
        conn.Do(rpush, "key", 1, 1, 2, 2, 3, 3)
        val2, _ := redis.Int64(conn.Do(llen, "key"))
        fmt.Println("llen", val2)
    
        conn.Do(del, "key")
        conn.Do(rpush, "key", 1, 1, 2, 2, 3, 3)
        val3, _ := redis.Int64(conn.Do(lset, "key", 1, 999))
        val4, err := redis.String(conn.Do(lindex, "key", 1))
        fmt.Println("lset", val3, val4)
    
    }
    ```
   
4. list
    ```go
        
    func setOperate() {
    conn := GetRedis()
    defer conn.Close()
    
        conn.Do(sadd, "set1", "xyk", "xyq", "xyl", "xyz", "xym", "xyu")
        val, _ := redis.Int(conn.Do(scard, "set1"))
        fmt.Println("sadd scard", val)
    
        val2, _ := redis.Bool(conn.Do(sismember, "set1", "xyk"))
        fmt.Println("sismember", val2)
    
        val3, _ := redis.Strings(conn.Do(srandmember, "set1", 2))
        fmt.Println("srandmember", val3)
    
        val4, _ := redis.Strings(conn.Do(smembers, "set1"))
        fmt.Println("smembers", val4)
    
        conn.Do(sadd, "set2", "xyk", "xyq", "xyl", "xyz", "xyv")
    
        val5, _ := redis.Strings(conn.Do(sdiff, "set1", "set2")) //set1-set2得到的结果
        fmt.Println("sdiff", val5)
    
        val7, _ := redis.Strings(conn.Do(sinter, "set1", "set2"))
        fmt.Println("sinter", val7)
    
        val8, _ := redis.Strings(conn.Do(sunion, "set1", "set2"))
        fmt.Println("sunion", val8)
    
        val9, _ := redis.Strings(conn.Do(spop, "set2"))
        val92, _ := redis.Strings(conn.Do(smembers, "set2"))
        fmt.Println("spop", val9, val92)
    
        val10, _ := redis.Strings(conn.Do(srem, "set1", "xyk", "xyq"))
        val102, _ := redis.Strings(conn.Do(smembers, "set1"))
        fmt.Println("srem", val10, val102)
    
        //sscan
        conn.Do("flushall")
        for i := 0; i < 1000; i++ {
            str := xstring.RandString(80)
            k1, _, k2, _ := fmt.Sprintf("key%02d%s", i, str), "val"+strconv.Itoa(i), fmt.Sprintf("name%02d", i), "val"+strconv.Itoa(i)
            conn.Do("sadd", "rootKey", k1)
            conn.Do("sadd", "rootKey", k2)
        }
        var pos int = 0
        var res []string
        xscan_(conn, sscan, "rootKey", &pos, 10, 10, "name*", &res)
        sort.StringSlice(res).Sort()
        fmt.Println("sscan res:", len(res), res)
    
    }
    ```
   
5. hash
    ```go
    
    func hashOperate() {
    conn := GetRedis()
    defer conn.Close()
    
        conn.Do(hset, "user:1:info", "age", 23)
        conn.Do(hset, "user:1:info", "height", 160)
        val, _ := redis.Int(conn.Do(hget, "user:1:info", "age"))
        fmt.Println("hset hget", val)
    
        //hgetall
        val2, err := redis.Strings(conn.Do(hgetall, "user:1:info"))
        if err != nil {
            fmt.Println(err)
        }
        fmt.Println("hgetall as []string", val2)
    
        val3, err := redis.StringMap(conn.Do(hgetall, "user:1:info"))
        if err != nil {
            fmt.Println(err)
        }
        fmt.Println("hgetall as map[string]string", val3)
    
        val4, err := redis.Bool(conn.Do(hexists, "user:1:info", "age"))
        if err != nil {
            fmt.Println(err)
        }
        fmt.Println("hexists", val4)
    
        val5, err := redis.Int(conn.Do(hlen, "user:1:info"))
        if err != nil {
            fmt.Println(err)
        }
        fmt.Println("hlen", val5)
    
        val6, err := redis.String(conn.Do(hmset, "user:1:info", "weight", 60, "hair", "long_black")) //返回的竟然是"OK"
        if err != nil {
            fmt.Println(err)
        }
        fmt.Println("hmset", val6)
        val62, err := redis.StringMap(conn.Do(hgetall, "user:1:info"))
        fmt.Println("hmset", val62)
    
        val7, err := redis.Strings(conn.Do(hmget, "user:1:info", "weight", "hair")) //这里如果用stringMap来获取的话会得到不合逻辑的结果，stringMap只是把每两个字符串转化为key:pair
        if err != nil {
            fmt.Println(err)
        }
        fmt.Println("hmget", val7)
    
        val8, err := redis.Strings(conn.Do(hvals, "user:1:info"))
        fmt.Println("hvals", val8)
    
        val9, err := redis.Strings(conn.Do(hkeys, "user:1:info"))
        fmt.Println("hkeys", val9)
    
        val10, err := redis.Bool(conn.Do(hincrby, "user:1:info", "weight", -8)) //正负值都支持
        fmt.Println("hincrby", val10)
        val11, err := redis.String(conn.Do(hget, "user:1:info", "weight"))
        fmt.Println("hincrby hget", val11)
    
        conn.Do(hdel, "user:1:info", "weight")
        val12, err := redis.StringMap(conn.Do(hgetall, "user:1:info"))
        fmt.Println("hdel", val12)
    
        //hscan
        conn.Do("flushall")
        for i := 0; i < 1000; i++ {
            str := xstring.RandString(80)
            k1, _, k2, _ := fmt.Sprintf("key%02d%s", i, str), "val"+strconv.Itoa(i), fmt.Sprintf("name%02d", i), "val"+strconv.Itoa(i)
            conn.Do("hmset", "rootKey", k1, "val1") //scan既可以扫描出字符串，对于集合和哈希等一样能够扫描出来
            conn.Do("hmset", "rootKey", k2, "val2")
        }
        var pos int = 0
        var res []string
        xscan_(conn, hscan, "rootKey", &pos, 10, 10, "name*", &res)
        //当hash对象所保存的键的数量小于512且key和value的长度都小于64个字节的时候hscan的count会失效
        //https://blog.csdn.net/dianxiaoer20111/article/details/120241141
        sort.StringSlice(res).Sort()
        fmt.Println("hscan res:", len(res), res)
    
    }
    ```
    

