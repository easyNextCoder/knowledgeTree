* 虚函数表
每个含虚函数的类中都会有一个虚函数表，每个类的实体中都有一个指向该表的指针放在实体地址的开始位置。
如果一个函数虚函数的类继承一个也含有虚函数的基类，那个这个基类的虚函数会被首先依次放到这个继承类的虚函数表的开头，之后放的是继承类的虚函数（可能会覆盖基类的虚函数）。
当出现一个继承类继承多个基类的时候，继承类会拥有多张表（每继承一个类就会多一张表）
> https://www.cnblogs.com/yinbiao/p/10987640.html

* 虚函数表的作用
虚函数表的作用：当使用父类指针来操作子类对象时，虚函数表就像一个地图一样，指明了实际所应该调用的函数

* 静态/动态绑定

静态绑定代码：

pb->Base Base::show 如果发现show是普通函数，就进行静态绑定
相关反汇编的代码：
call        Base::show (0126143Dh)

动态绑定代码：
相关反汇编的代码：

? 
mov???????? eax,dword ptr [pd]
? 
mov???????? edx,dword ptr [eax]
? 
mov???????? esi,esp
? 
mov???????? ecx,dword ptr [pd]
? 
mov???????? eax,dword ptr [edx+4]
? 
call?????? ? ? eax


显然，寄存器中的值只有在运行的时候可以确定，故称之为动态绑定。（查表之后才能得到函数地址，而不能在编译时期就获得函数入口地址，所以叫动态绑定）
>https://blog.csdn.net/qq_42418668/article/details/96134812

* 为什么动态绑定的运行效率比较低？
设想一下，如果说不是虚函数，那么在编译时期，其相对地址是确定的，编译器可以直接生成jmp/invoke指令；?
如果是虚函数，多出来的一次查找vtable所带来的开销，倒是次要的，关键在于，这个函数地址是动态的，譬如?
取到的地址在eax里，则在call eax之后的那些已经被预取进入流水线的所有指令都将失效。流水线越长，一次分支预测失败的代价也就越大。

原文链接：https://blog.csdn.net/sunshinewave/article/details/51079204
