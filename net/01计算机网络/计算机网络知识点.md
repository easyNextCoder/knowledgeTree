# OSI七层模型

7. 应用层(**Application**)
8. 表示层(Presentation)
9. 会话层(Session)
10. 传输层(**Transport**)
11. 网络层(**NetWork**)
12. 数据链路层(**Data link**)
13. 物理层(Physical)

## 应用层
* 应用层功能
	* 提供网络服务的接口
* 应用层服务（各种协议）
  * 文件传(FTP)
  * 电子邮件(SMTP)
  * Web(HTTP)
  * FTP
  * TELNET
  * RIP
## 表示层
* 表示层功能
	* 数据表示转化
		* 转换为主机独立的编码
	* 加密/解密
	* 压缩/解压缩

## 会话层

## 传输层

* 传输层功能：
  
  实现端到端的可靠数据传输
  
* 传输层协议

  TCP/UDP
  
* 传输层功能简述
  
  * 端到端的完整报文传输
  * **报文的分段与重组**
  * SAP寻址
  * 连接控制
  * 流量控制
  * 拥塞控制
  * 差错控制
  * **对话控制**
  * 同步
  
* 传输层功能详述
  
  * 负责源-目的（端-端） （进程间）完整报文传输
  
  * 分段与重组
  
  * SAP寻址
  
    * SAP又叫做服务访问点，是一个层次系统的上下层之间进行通信的接口，N层的SAP就是N+1层可以访问N层服务的地方
    * 确保将完整报文提交给正确进程，如端口号
  
  * 连接控制
  
  * **流量控制**
  
    * 使用流水线机制和**滑动窗口**的方法，提高传输效率
      * 流水线机制
        
        * 比如连续发送三个分组，然后再等待，成倍增加性能（一次发送多少数据，增加了多少倍）
        
      * 流水线协议：
        * 允许发送方在收到ACK之前连续发送多个分组
          * 更大的序列号范围
          * 发送方和/或接收方需要更大的存储空间以缓存分组
        
      * 滑动窗口协议
        * 滑动窗口协议：Sliding-window protocol
        * 窗口
          * 允许使用的序列号范围
          * 窗口尺寸为N：最多有N个等待确认的消息
        * 滑动窗口
          
          * 随着协议的运行，窗口在序列号空间内**向前滑动**
        
      * 滑动窗口协议：GBN(Go-Back-toN超时重新回到N，重发),SR （Selective Repeat选择重传协议）
          * GBN的发送方有缓存，而GBN的接收方没有缓存，消息包有可能乱序到达接收方，但是如果发送过来的序列号大于已经确认的序列号，**直接丢弃**
            
          * 自动机图：https://www.icourse163.org/learn/HIT-154005?tid=1206679208#/learn/content?type=detail&id=1211458183&cid=1214120332
      
          * 滑动窗口中的三种重传协议
              滑动窗口中断三种协议分别是：（从滑动窗口的观点统一看这三种协议）他们的差别仅在于窗口尺寸的大小不同而已。
      
              * 停等协议
      
                  发送窗口=1，接收窗口=1
      
              * GBN协议
      
                  发送窗口>1，接收窗口=1
      
              * SR协议
      
                  发送窗口>1，接收窗口>1
      
          * GBN协议
      
              GBN协议中，发送方在发完一个数据帧后，连续发送若干个数据帧，即使在连续发送过程中收到了接收方发来的应答帧，也可以继续发送。且发送方在每发送完一个数据帧时都要设置超时定时器。**只要在所设置的超时时间内仍未收到确认帧，就要重发相应的数据帧。如：当发送方发送了N个帧后，若发现该N帧的前一个帧在计时器超时后仍未返回其确认信息，则该帧被判为出错或丢失，此时发送方就不得不重新发送出错帧及其后的N帧**。
      
              接受帧只允许按顺序接受帧。为了减少开销，累计确认允许接收端在连续收到好几个正确的确认帧后，只对最后一个数据帧发确认信息，或者可以在自己有数据要发送时才将对以前正确收到的帧加以捎带确认。这就是说，对某一数据帧的确认就表明该数据帧和这以前所有的数据帧均已正确无误地收到了。
              后退N帧协议的接受窗口为1，可以保证按序接受数据帧。若采用n个比特对帧编号，则其发送窗口的尺寸应满足：1~2(n-1)。若发送窗口的尺寸大于2(n-1)，则会造成接受方无法分辨新帧和旧帧。(具体例子见书)
      
          * SR(Selective Repeat)协议
      
              * 简单来讲就是继续接收发送的，但是要求重传出错的那一帧
          
      * 优点：降低了重传的数量，减少了浪费
        
      *  缺点：接收方需要有一定数量的缓冲空间
         
          SR协议是当接收方发现某帧出错后，其后继续送来的正确的帧虽然不能立即递交给接收方的高层，但接收方可收下来，存放在一个缓冲区中，同时要求发送方重新传送出错的那一帧。一旦收到重新传来的帧后，就可以原已存于缓冲区中的其余帧一并按正确的顺序递交高层。显然，SR减少了浪费，但要求接收方有足够大的缓冲区空间。
              
              若采用n比特对帧编号，为了保证接收方向向前移动窗口后，新窗口序号与旧窗口序号没有重叠部分，需要满足条件：接受窗口+发送窗口<=2n。假定仍然采用累计确认的方法，并且接受窗口显然不应超过发送窗口，那么接受窗口尺寸不应超过序号范围的一半<=2(n-1)。
              
              ​    
          
          
          ​     
      
    * 拥塞控制的四种方法
      
      * > 拥塞避免和慢启动算法-通常是配合工作的
      
    * > www.cnblogs.com/ggjucheng/archive/2012/02/03/2337420.html
      
      * CongWin-拥塞窗口 = LastByteSent-LastByteAcked
        * 动态调整以改变发送速率
        * 反映所感知到的网络拥塞
  
      * 慢启动
        当连接刚刚开始的时候将拥塞窗口呈指数型增长，每个RTT将CongWin翻倍，收到每个ACK进行操作；初始速率很慢，但是快速攀升。
      
      * 加性增，乘性减
      
        （**超过Threshold后**)加性增，(**发生拥塞后**)乘性减（CongWin变成一半）；(逐渐增加发送速率，谨慎探测可用带宽<锯齿行为>，发生loss后将CongWin减半)
      
      * 快速恢复，快速重传 
      
      * Loss事件的处理：拥塞事件两种1.超时2.收到重复确认的ACK
        * 收到3个重复ACKs
          * CongWin切到一半
          * 然后线性增长
        * Timeout事件
          * CongWin直接设为1个
          * 然后指数增长
          * 达到threshold后，再线性增长
        * 为什么这两个处理不一样？
          * 还能收到ACK说明网络并不是很拥堵
          * timeout表明网络非常拥塞
  
  * 差错控制
  
  * 对话控制
  
    * 建立，维护
  
  * 同步
  
    * 在数据流中插入“同步点”
  
* 更详细的功能介绍
  * 多路复用/分用
    * 接收端进行多路分用：传输层依据头部信息将收到的Segment交给正确的Socket即不同的进程
  * 发送端进行多路复用
    * 从多个Socket接收数据，为每个块数据封装上头部消息，生成Segment，交给网络层。

* TCP报文格式：
	
	![TCP报文格式](.\TCP报文格式.jpeg)
	
	* 序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
	* 确认号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack = seq+1
	* 标志位：共六个URG,ACK,PSH,RST,SYN,FIN
		* URG:紧急指针有效
		* ACK：确认序号有效
		* PSH：接收方应该尽快将这个报文交给应用层
		* RST：重置连接
		* SYN:发起一个新连接
		* FIN：释放一个连接
	* 16位窗口大小：是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口(Receiver Window, RWND).它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据。这样对方就可以控制发送数据的速度。
	* 16位检校和（TCP check sum）：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程种是否损坏。注意，这个检校不仅包括TCP头部，也包括数据部分。是TCP可靠传输的一个重要保障
	* 16位紧急指针：这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。
	
* 传输层负责可靠的数据传输
	* 什么叫可靠的数据传输？
		* **不错，不丢，不乱**
	* 如何实现数据的可靠传输
		* **检校和**解决**不错**问题
		* **ACK确认机制**和**重传机制**解决**不丢**的问题
		* **序列号**解决**不乱**的问题
		* 另外还有一个定时器解决无限等待问题

## 网络层

* 网络层功能的简述：寻址路由和转发

* 网络层协议：IP ICMP IGMP RAP RARP （RIP OSPF BGP） NAT

* 网络层功能
	* 负责**源主机到目的主机**数据分组(packet)交付（分片）
		* 可能穿越多个网络
	* 逻辑寻址
		* 全局唯一逻辑地址，确保数据分组被送达目的主机，如IP地址
	* 路由
		* 路由器（或网关）互连网络，并路由分组至最终目的主机
		* 路径选择
	* 分组转发（从发送主机向接收主机发送数据段，分组后转发到目的主机，目的主机再把信息拼接）
	
* 网络层IP数据报格式
	
	​	![数据报格式](.\IP数据报格式.PNG)
	
	* 版本号字段占4位，：IP协议的版本号  e.g.  4->ip4  6->ip6
	* 首部长度字段占4位：IP分组首部长度
		* 以4字节为单位
		* e.g.->IP首部长度为20（5*4）字节    一般情况下都是20个字节
	* 服务类型（TOS）字段占8位：指示期望获得那种类型的服务
		* 1998年这个字段改名为区分服务
		* 只有在网络提供区分服务(DiffServ)时使用
		* 一般情况下不使用，通常IP分组的该字段(第2字节)的值为00H
	* 总长度字段占16位：IP分组的总字节数（首部+数据）
		* 最大IP分组的总长度：65535B
		* 最小的IP分组首部：20B
		* IP分组可以封装的最大数据：65535-20=65515B
	* 标识：占16位
	* 标志位：占4位
	* 片偏移：占12位（以上三个都与数据报的分片有关）
	* 生存时间（TTL）字段占8位：IP分组在网络中可以通过的路由器数（或跳步数）
		* 路由器转发一次分组，TTL减1
		* 如果TTL=0，路由器则丢弃该IP分组（并向源地址发送一个ICMP报文）
	* 协议字段占8位：指示IP分组封装的是哪个协议的数据包
		* 实现复用/分解
		* e.g.6表示封装的TCP段，17表示封装的UDP数据报，也可以表示是ICMP报文
	* 首部检校和字段占16位：实现对IP分组首部差错检测
		* 计算检校和时，该字段置**全0**
		* 采用反码算术运算求和，和的反码作为首部检校和字段
		* 逐跳计算逐跳检验
	* 源IP地址、目的IP地址字段各占32位：分别标识发送分组的源主机/路由器（网络接口）和接收分组的目的主机/路由器（网络接口）的IP地址
	* 选项字段：占长度可变，范围在1-40B之间：携带安全、源选路径、时间戳和路由记录等内容
		* **实际上很少被使用**
	* 填充字段：占长度可变，范围在0-3B之间：目的是补齐整个首部，符合32位对齐，即保证首部长度是4字节的倍数
	
* 网络层的协议
  * IP协议
    * ICMP协议
  * DHCP协议
  * NAT协议
  * 路由协议
    * RIP协议（路由信息协议）
    * OSPF协议
    * IGRP协议
    * BGP协议
  * RAP协议
  
* IP协议
	* IP编址
		* IP地址
			* （网络号NetID-高比特位）
			* （主机号HostID-低比特位）
		* IP子网
			* IP地址具有相同网络号的设备接口
			* 不跨越路由器可以彼此物理联通的接口
	* 有类IP地址
		* A类地址 <NetID(8位）HostID(24位）>0.0.0.0-127.255.255.255(占所有网路地址的50%) ->0开头
		* B类地址<NetID(16)位 HostID（16位）>128.0.0.0-191.255.255.255（占所有网络地址的25%）->10开头
		* C类地址<NetID(24)位 HostID（8位）>192.0.0.0-223.255.255.255（占所有网络地址的25%）->110开头
		* D类地址<总长32位>224.0.0.0-239.255.255.255（占所有网络地址的25%）->1110开头
		* E类地址<总长32位>240.0.0.0-255.255.255.255（占所有网络地址的25%）->1111开头
	* 特殊IP地址（见外面文件夹的图片）
		* A类地址中的全0地址->在本网范围内表示本机，在路由表中表示默认路由（相当于表示整个Internet网络）可以作为源IP不可作为目的IP
		* A类地址中全1->本网广播地址（路由器不转发）不可以作为源地址，可以作为目的地址
		* 127.后面是非全0或者非全1，->用于本地软件环回测试，可以作为源IP也可以作为目的IP
	* 子网掩码：实现高级大型子网划分为更小的子网（但是会存在HostID为全0  或者是全1的情况下，被浪费了不能分配使用的情况）
	* CIDR（无类域间路由）与路由聚合
		* CIDR：消除传统的A类，B类和C类地址界限，方便子网划分
	
* ICMP协议：互联网控制报文协议
	* 功能：支持主机或路由器
		* 差错(或异常）报告
		* 网络探寻
	* 两类ICMP报文
		* 差错报告报文（5种）
			* 目的不可达
			* 源抑制（Source Quench）
			* 超时/超期
			* 参数问题
			* 重定向
		* 网络探寻报文（2组）
			* 回声请求与应答报文(Reply)
			* 时间戳请求与应答报文
	
* DHCP协议（动态主机配置协议：解决如何获取IP地址）
	* 从服务器动态获取
		* IP地址
		* 子网掩码
		* 默认网关地址
		* DNS服务器与IP地址
	* 即插即用
	* 允许地址重用
	* 支持在用地址续租
	* 支持移动用户加入网络
	* **DHCP协议在应用层实现**
		* 请求报文封装到UDP数据报中
		* IP广播
		* 链路广播
	* **DHCP服务器构造ACK报文**
		* 包括分配给客户的IP地址，子网掩码，默认网关，DNS服务器地址
	
* NAT协议（网络地址转换）

* 路由协议
	
	* 路由算法分类
		
		* 静态路由or动态路由
			* 静态路由：手工配置，更新慢，优先级高
			* 动态路由：路由更新快（及时响应链路费用或网络拓扑变化）
		* 全局信息or分散信息
		  * 全局信息：所有路由器掌握完整的网络拓扑和链路费用信息。E.g.链路状态（LS）路由算法
		  * 分散信息：路由器只掌握物理相连的邻居以及链路费用；邻居间信息交换，运算的迭代过程。E.g.距离向量(DV)路由算法
		
	* 全局信息算法-Dijstra算法
	
	  * 算法复杂度：n个结点
	
	    * 每次迭代：需要检测所有不在集合N'中的结点w
	    * n(n+1)/2次比较O（n^2）
	    * 更高效的实现:O(nlogn)
	
	  * 存在震荡的可能：
	
	    ![](C:\Users\xyk\Desktop\knowledgeTree\计算机网络\01计算机网络\route-dijkstra.jpg)
	
	* 距离向量(Distance Vector)路由算法
	  基于Bellman-Ford方程（动态规划）
	  异步迭代：引发每次局部迭代的因素：局部链路费用改变，来自邻居的DV更新
	  分布式计算：每个结点只当DV变化时才通告给邻居
	* 层次化路由-一种路由策略
	  无论是链路状态算法还是距离向量算法-都是讲整个网络抽象成一张图，但是当一个网络过大时，抽象成一张网络来进行计算就过于理想了。因此在实际网络尤其是大规模网络-不可行
	  ![](C:\Users\xyk\Desktop\knowledgeTree\计算机网络\01计算机网络\层次化路由.jpg)
	* AS内部协议也成为内部网络协议IGP（interior gateway protocols）
	  最常见的AS内部路由协议有三个
	  * 路由信息协议：RIP（Routing Information Protocol）
	  * 开放最短路径优先：OSPF(Open Shortest Path First)
	  * 内部网关路由协议：IGRP(Interior Gateway Routing Protocol)-Cisco私有协议
	
	* RIP协议：路由信息协议（**是在应用层实现的**）
	  * 采用**距离向量路由算法**-利用跳步数来衡量距离远近
	  * 算法简单性能不好
	* OSPF协议：开放最短路径优先
	  * 采用链路状态路由算法
	  	* (利用**迪杰斯特拉算法**计算路由)
	  	* LS分组扩散（通告）
	  	* 每个路由器构造完整的网络（AS)拓扑图
	  	* 算法复杂但是性能更好
	  * OSPF协议的优点：
	  	* 安全：所有OSPF报文可以被认证（预防恶意入侵）
	  	* 允许使用多条相同费用的路径（RIP只能选一条）**能够使网络负载更均衡。**
	  	* 对于每条链路，可以针对不同的TOS设置多个不同的费用度量(能够实现不同类型的数据的分流)
	  	* 集成单播路由与多播路由
	* IGRP协议：内部网关路由协议
	  
	  * 思科的私有协议
	* BGP协议（边界网关协议：将Internet粘合成一个整体的关键）
	  * 为每个AS提供了一种手段
	  	* eBGP:从邻居AS获取子网可达性信息
	  	* iBGP:向所有AS内部路由器传播子网可达性信息
	
* RAP协议（属于局域网中的协议）RARP协议
	
	* 实现由IP地址到MAC物理地址的转换（是通过一个RAP表实现的）
	
* 网络层功能最简洁的总结

  * 路由协议
    * 路径选择
    * RIP, OSPF, BGP

  * 承接作用的是路由表

  * IP协议
    * 寻址规约(conventions）
    * 数据报（分组）格式
    * 分组处理规约
  * ICMP协议（网络控制报文协议 是TCP/IP的子协议）
    * 差错报告
    * 路由器"信息"
    * 功能：
      * 侦测远端主机是否存在
      * 建立及维护路由资料
      * 重导资料传送路径
      * 资料流量控制
  
* 小结：
	* IP ICMP数据报型协议
	* DHCP 路由协议 （NAP RAP处于网络层和链路层之间的协议又都属于局域网中的技术）都是服务型协议 
	
* ICMP(internet control management protocol) IGMP(internet group management protocol)作者：车小胖
  链接：https://www.zhihu.com/question/27668104/answer/11602630

  **再比如ICMP/IGMP属于网络层还是传输层？**
  ICMP，IP Control Management Protocol 
  IGMP，IP Group Management Protocol 
  把它们的全称写出来童鞋们就应该明白**它们都属于IP层，IP层属于网络层，它们也是。**本来它们的存在就是为了辅助IP层工作的，ICMP处理IP层出错，IGMP可以帮助一个主机加入一个组播组。当网络出错时，比如IP TTL expired，或 IP Destination Unreachable 都会产生ICMP Error Message，没有这些辅助协议的帮助，IP层单打独斗也不现实，至少要在IP头里增加如何处理出错的报文头。

  **PPTP/L2TP 很显然属于传输层。**因为设计它们的时候就是为了传输PPP协议的，可以让PPP协议脱离物理连接的限制，可以让PPP client 与 PPP server 不再拘泥于物理的连接，可以在PPP client 与 PPP server 之间存在一个或大或小的IP网络、或Internet，而实现这个物理分离技术的正是PPTP/L2TP。

  **OSPF/ISIS/RIP/BGP 很显然属于网络层。**无论它们工作在IP，CLNS，UDP，TCP之上，都可以把它们统统归类于网络层，因为它们提供的是网络层的导航信息。但BGP比较特殊，它**严重依赖于IGP，它需要别的IGP正常工作才可以正常工作，IGP相当于它的外包（outsourcing）！**

* TCP分组IP分片
  MSS(最大分段大小) MTU（最大传输单元）
  MSS是由TCP建立连接的时候二者协商得到的，MTU是IP协议中规定的最大为1500B

  当TCP一次要传输的数据大于MSS时要在传输层进行分组，而如果MSS大于MTU则在IP协议下进行传输时，需要分片。由于分片是要路由器来完成，占用大量的CPU资源，所以尽量不要分片，也就是MSS要尽量选的合适

  > https://blog.csdn.net/coolwriter/article/details/83721011
## 链路层

* 链路层功能简述：组帧，寻址实现节点到结点之间的传输；同时进行流量控制，差错检测和访问控制。
* 数据链路层功能
	* 负责结点-结点(node-to-node)数据传输
	* 组帧(Framing)（将上层的IP数据报进行组帧发送；也就是对网络层进行分组传输）
	* 链路接入/物理寻址(Physical addressing)
		* 在帧头中增加发送端和/或接收端的物理地址表示数据帧的发送端和/或接收端（使用MAC地址来寻找，不同于IP地址）
	* **流量控制**（连接的两个节点间的流量控制）
		* 避免淹没接收端
	* **差错检测**
		* 检测并重传损坏或丢失帧，并避免重复帧
	* **访问控制**
		* 在任一给定时刻决定哪个设备拥有链路（物理介质）控制使用权。
	* 为什么传输层已经有了流量控制和差错检测，数据链路层还要有？
	  * 一个军队的运行不仅需要师长，还需要连长共同指挥
* 两类链路
	* 点对点链路
		* 拨号接入的**PPP协议**
			* PPP数据帧格式
				* 表示(Flag):定界符(delimiter)开始和结束各有一个定界符
				* 地址(Address):无效（仅仅是一个选项)
				* 控制(Control）：无效；未来可能的多种控制域
				* 协议(Protocol):上层协议(eg:PPP-LCP, IP, IPCP,etc)
				* 信息(info):上层协议分组数据（数据中可能有定界符，如果有则加上另一种类型的定界符1，如果这种定界符1也存在则在定界符1之前加上一个定界符1，当进行解释的时候连续出现两个这种定界符1则抛弃前一个）
				* 检校(check):CRC检校，用于差错检测
		* 以太网交换机之间的点对点链路
	* 广播链路（共享介质）
		* 广播链路的分类
			* 早期的总线以太网
			* HFC的上行链路
			* **802.11**无线局域网
		* 广播链路存在的问题
		  * 单一共享广播信道
		  * 两个或者两个以上结点同时传输：产生干扰
		    * 冲突
		      * ​	结点同时接收到两个或者多个信号->接收失败
		      * 如何解决冲突，采用多路访问控制协议
* MAC协议总结：
	* MAC协议的特点：
	  * 采用分布式算法决定如何共享信道，即结点自身来决定何时可以传输数据
	  * 基于信道本身，通信信道共享协调信息（无外信道帮助）
	* **MAC协议**叫做：（英语：Media Access Control Address）
	* 信道划分MAC协议：时间，频带，码片划分
	  * TDMA, FDMA, CDMA
	  * 特点：信道已经经过划分绝对不会出现冲突
	* 随机访问MAC协议（局域网中非常多见）
	  * ALOHA,S-ALOHA,CSMA
	  * CSMA/CD用于以太网（带有冲突检测的随机访问控制协议）
	  * CSMA/CA应用于802.11无线局域网（无线链路中无法检测数据是否有冲突）
	  * 特点：
	    * 当发送数据的时候就利用这个信道的全部带宽
	    * 信道不划分，允许冲突
	    * 采用冲突“恢复”机制
	* 轮转访问MAC协议
	  * 主节点轮训，令牌传递
	  * 蓝牙，FDDI,令牌环网

## 物理层

* 物理层功能
	* 接口特性
		* 机械特性、电器特性、功能特性、规程特性
	* 比特编码
	* 数据率
	* 比特同步
		* 时钟同步
	* 传输模式
		* 单工(simplex)
		* 半双工(half-duplex)
		* 全双工(full-duplex)

# 其他知识点

## MTU & MSS

MTU（Maximum Transmit Unit）以太网最大传输单元，

MSS（Maximum Segment Size）传输层TCP最大分段大小

MTU：以太网Ethernet的最大数据帧是1518Bytes，出去以太网的帧头(14Byte的帧头，4Byte的CRC检校帧尾)，那么剩下承载上层协议的地方也就是Data域最大的就只能有1500Byte。这个值就是MTU。

MSS：最大报文段大小为1460，由1500-20（IP头）-20（TCP头）计算出的。实际场景下，TCP包头中会带有12字节的时间戳。于是单个TCP包实际传输的最大量就缩减为1448字节：1448=1500-20（IP头）-32（TCP头+时间戳）

MSS就是TCP数据包每次能够传输的最大量，在建立连接的时候通常要双方协商MSS值

粘包：TCP发了两个数据，A数据长度18Byte；B数据长度14Byte.接收端会一下子接收32Byte的数据。

解决粘包：每段数据前加一个2Byte的长度，用来表示这个数据的实际长度。接收端先读2Byte的到剩下的数据的长度再读取后面的数据就是A的数据了。



## 网络中的定时器

1.建立连接定时器

在发送SYN请求时定时器启动,如果在定时器期间没有收到服务器的回应(75秒),则自动关闭连接,连接立即终止

2.超时重传定时器

超时重传定时器,在TCP发送某个数据段时设定,如果在一定时间内,没有收到对端的回应,TCP将认为你这段数据丢失,开始进行重传,超时重传定时器的值是动态设定的,根据网络环境,拥塞控制等,与RTT(数据包往返一次需要的时间)的值密切相关

3.延迟应答定时器

   延迟应答定时器,在TCP收到数据包时必须确认,但不必马上确认时设定,如果在这段时间有需要发送的数据,则会和这个确认消息一同被发出(捎带应答),如果并没有其他信息需要发送,在延迟应答定时器结束后,TCP回复应答

4.持续定时器

“持续 (persist)”定时器在连接对端通告接收窗口为0，阻止TCP继续发送数据时设定。由于连接对端发送的窗口通告不可靠(只有数据才会被确认，ACK不会被确认)，允许TCP继续发送数据的后续窗口更新有可能丢失。因此，如果TCP有数据要发送，但对端通告接收窗口为0，则持续定时器启动，超时后向对端发送 1字节的数据，判定对端接收窗口是否已打开。

5.保活定时器

如果连接空闲两个小时,则保活定时器超时,此时向对方发送探测性报文,强迫对端进行回应,如果收到了期待的回答,则TCP确定对端主机正常运行,在该连接再次空闲两小时之前不会再进行探测,如果收到了为RST响应,则确定对端主机正在重启,如果探测多次以后没有任何响应,则TCP认为,对方主机崩溃,然后关闭连接

6.FIN_WAIT2定时器

当某个连接从FIN_WAIT1变为FIN_WAIT2状态时设定该定时器,设定为10分钟,超时后设定为75秒,如果第二次超时,还没有收到FIN请求,连接直接关闭,避免对端不发送FIN请求,连接一直停留在FIN_WAIT2状态

7.TIME_WAIT定时器

TIME_WAIT定时器设定为2MSL,在主动关闭的一段最后一次回复ACK以后进入TIME_WAIT状态,为了防止最后回复的ACK请求没有被对端收到而影响下一次连接,MSL为数据存在的最大生命周期,设定为2MSL确定最后的ACK已经彻底消失,TIME_WAIT定时器结束后主动关闭方,可以关闭自己的资源

## 局域网

* 局域网的简单描述：（属于网络层中的大网中的一个小网络组织）

* ARP协议
* 以太网（统治地位的有限局域网技术）（使用CSMA/CD进行冲突域检测）
	* 特点
		* 便宜、造价低
		* 一直能满足网络速率需求从10k-10G
	* 组成
		* 使用共享介质
		* 存在**冲突域**（两个节点同时发送信息可能发生冲突的一个域叫做冲突域)
		* 一开始是总线形式（但是任意两个节点同时发送的时候会存在冲突），后来使用星型拓扑（中间有交换器节点之间不存在冲突域）
	* 不可靠、无连接的服务（链路层中）
		* 无连接：发送帧的网卡与接收帧的网卡间没有握手过程
		* 不可靠：接收网卡不向发送网卡进行确认。（没有确认机制就没有可靠性）
		* 如何处理差错？由于是在局域网内进行传输所以数据出现差错的几率很小，发现有错误的数据帧直接丢弃，之后依靠高层协议来进行处理。
	* 以太网的MAC协议：采用二进制指数退避算法的CSMA/CD协议（算法作用，当出现冲突只有计算出等待时间然后再次重新尝试发送数据）
	* 可以封装IP数据报或者其他的网络层的数据分组（发送端网卡将IP数据报<或其他网络层协议分组封装到以太网帧中>）
	* 以太网帧的结构
		* 前导码(Preamble)(8B):前7个字节的10101010（同步）,第8个字节的10101011
		* 目的MAC地址、源MAC地址  分别是6个字节 广播地址为48个全1，网卡只接受跟自己MAC地址相符的数据帧，或者是广播的数据帧
		* 类型(Type)(2B):指示帧中封装的是那种高层协议的分组（如：IP数据报，Novell IPC数据报，AppleTalk数据报等）**实现以太网的复用分用**
		* 数据(Data)(46-1500B):指上层协议载荷
		* CRC(4B)：循环冗余检校码
	* **（物理层相关）**许多不同的以太网标准
		* 相同的MAC协议和帧格式
		* 不同速率:2Mbps, 10Mbps,100Mbps，1Gbps,10Gbps
		* 不同的物理介质：比如有铜缆（双绞线链路）也有光纤链路
* PPP协议（点对点链路）
* 802.11无线局域网协议

## 互联网安全
* 解决方案：秘钥分发和公钥认证
* 对称秘钥如何分发？
	* 借助两方都信任的秘钥分发中心（KDC)来分发
* 公钥认证
	* 任何一个要发公开秘钥都要去CA去认证，得到公钥证书。
	* 别人拿到公钥证书之后可以去认证中心进行解密

## 综合OSI和TCP/IP的优点

* 应用层：支持各种网络应用
	* FTP, SMTP, HTTP
* 传输层：进程-进程的数据传输
	* TCP,UDP
* 网络层：源主机到目的主机的数据分组路由与转发
	* IP协议，路由协议
* 链路层：相邻网络元素（主机，交换机，路由器等）的数据传输
	* 以太网(Ethernet),802.11(WiFi),PPP
* 物理层：比特传输

## 交换机和路由器

* 交换机：只有两层链路层和物理层
  * 交换机主要工作在数据链路层（第二层）
  * 交换机转发依据对象MAC地址，物理地址
* 路由器：有三层多了一层网络层
  * 路由器工作在网络层（第三层)
  * 路由器转发依据对象IP地址，网络地址

**专业点说:**

交换机à工作在数据链路层，隔离了冲突域，能够学习数据帧当中携带的源MAC地址来构建MAC地址表，同时负责查找目的MAC地址智能的转发数据。

路由器à工作在网络层，隔离了广播域，通过静态路由或者动态路由协议构建路由表，能够依据数据包当中的目的IP地址智能的转发数据。

**简单点说:**

交换机à负责将所有终端设备连接在一起的设备，主要负责一个公司、学校内部设备之间的通信。

路由器à负责将企业内网的数据包发送到互联网，主要用来负责连接企业内网和外网的设备。

链接：https://www.zhihu.com/question/20465477/answer/709542351


## 传输层的服务
* TCP服务
	* 面向连接：客户机、服务器进程间需要建立连接
	* 可靠的传输
	* 流量控制：发送发不会发送速度过快，超过接收方的处理能力
	* 拥塞控制：当网络负载过重时能够限制发送方的发送速度
	* 不提供时间/延迟保障
	* 不提供最小带宽保障
* UDP服务
	* 无连接
	* 不可靠的数据传输
	* 不提供：
		* 可靠性保障
		* 流量控制
		* 拥塞控制延迟保障
		* 带宽保障

* 二者服务的差别和总结：
	
* UDP
	* 基于Internet IP协议
		* 复用/分用
		* 简单的错误校验
	* Best effort服务，UDP段可能
		* 丢失
		* 非按序到达
	* 无连接
		* UDP发送方和接收方之间不需要握手
		* 每个UDP段的处理独立于其他段 

## TCP连接池

1. 为什么要使用TCP连接池？

   减少连接的创建和关闭，增加系统负载能力。实际工作中可能需要的问题：TCP  TIME_WAIT连接数过多导致服务不可用，因为未开启数据库连接池，再加上mysql并发较大，导致需要频繁创建链接，最终产生了上万的TIME_WAIT的tcp链接，影响了系统性能。

## 各种类型应用占用的端口

* http占用的端口是80端口
* https占用的端口是443
* 邮件发送占用的端口是25端口

## MAC地址

 *（英语：Media Access Control Address）

mac地址是包含在以太网的头部当中。以太网头部帧一般包含：

目的MAC地址，源MAC地址，以太类型，前导码，检校等一共18个字节（14个有用信息，4个无用信息）



## HTTP

### 技术规定

http：超文本传输协议。是基于客户端/服务端（C/S）的构架模型，通过可靠的链接来交换信息，是一个**无状态**的请求/响应协议。

http客户端和服务端都是一个应用程序。

http使用统一资源标识符(Uniform Resource Identifiers,URL)来传输数据和建立连接

http请求到服务器的请求消息包括以下格式：请求行（request line）、请求头（header）、空行和请求数据四个部分。

http1.0定义了三种请求方法：GET, POST和HEAD方法

http1.1新增了5种请求方法：OPTIONS, PUT, DELETE, TRACE和CONNECT方法。

### 请求方式

GET：请求指定的页面信息，并返回实体主体

POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求实体种。POST请求可能会导致新的资源的建立和/或已有资源的修改。

```
GET     请求指定的页面信息，并返回实体主体。
HEAD    类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
POST    向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
PUT     从客户端向服务器传送的数据取代指定的文档的内容。
DELETE    请求服务器删除指定的页面。
CONNECT    HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
OPTIONS    允许客户端查看服务器的性能。
TRACE    回显服务器收到的请求，主要用于测试或诊断。
```

### 名词解释

URI和URL：统一资源定位符URL，URI统一资源标识符。URL是URI的一个子集，是URI的一种实现方式。

比如我们可以使用：//地球/中国/浙江省/杭州市/西湖区/某大学/14号宿舍楼/525号寝/张三.人来定位一个资源

也可以使用身份证号：9527来定义标记一个资源

GET和POST：get用来获取数据，post用来提交数据

简单的区别：

- GET用于从服务器端获取数据，包括静态资源(HTML|JS|CSS|Image等等)、动态数据展示(列表数据、详情数据等等)。
- POST用于向服务器提交数据，比如增删改数据，提交一个表单新建一个用户、或修改一个用户等。

```
GET后退按钮/刷新无害，POST数据会被重新提交（浏览器应该告知用户数据会被重新提交）。
GET书签可收藏，POST为书签不可收藏。
GET能被缓存，POST不能缓存 。
GET编码类型application/x-www-form-url，POST编码类型encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。
GET历史参数保留在浏览器历史中。POST参数不会保存在浏览器历史中。
GET对数据长度有限制，当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。POST无限制。
GET只允许 ASCII 字符。POST没有限制。也允许二进制数据。
与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。
GET的数据在 URL 中对所有人都是可见的。POST的数据不会显示在 URL 中。
```

原理性区别：

Get产生一个TCP数据包；Post产生两个TCP数据包。

对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
对于POST，浏览器先发送header，服务器响应100（continue），然后再发送data，服务器响应200（返回数据）

> https://www.zhihu.com/question/28586791/answer/571627708

总结抽象：

GET的语义是请求获取指定的资源。GET方法是安全、幂等、可缓存的（除非有Cache-ControlHeader的约束），GET方法的报文主体没有任何语义。

POS的语义是分局请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST不安全，不幂等，不可缓存。

> https://www.zhihu.com/question/28586791/answer/145424285
> 

### http的返回值

1**继续操作信息，服务器收到请求，需要请求者继续执行操作

2**成功，操作被成功接收并处理

3** 重定向,需要进一步的操作以完成请求

4** 客户端错误，请求包含语法错误或无法完成请求

5** 服务器错误，服务器处理请求的过程中发生了错误

常见的：

200：标识从客户端发送的请求在服务端被正常处理了。

301：永久性重定向，表示请求的资源已经被分配了新的URI。

302：临时性重定向。

400：表示请求的报文中存在语法错误

401：表示发送的请求需要通过HTTP认证。

403：表示请求的资源的访问被服务器拒绝了。

404：表示请求的资源在服务端无法找到。

500：表示服务器端在执行请求时发生错误（可能是应用程序bug或服务器故障）

503：表示服务器暂时处于超负荷或者正在停机维护，无法处理请求。

### request

一个标准的HTTP请求由以下几个部分组成：

1. <request-line>

2. <headers>

3. [<request-body>]

request-line:用来说明请求方法(request method)，要访问的资源（URL），使用到的HTTP版本

headers:用来说明服务器要使用的附加信息，比如

​				接受的语言

​				接受的编码

​				连接状态

​				UA-CPU:x86

​				User-Agent:Mozilla/4.0

​				Cookie信息等

​				Content-Length

​				...

request-body:根据需要可以在头部信息结束后增加主体数据（可选，如果请求方法时GET，则没有这个部分/r用于标记结束）

### http1.0/1.1/2.0与https

HTTP1.0/1.1/2.0的区别

一、http 1.0 与 1.1

1.0在网页中的使用是在1996年，而1.1却在才开始应用在广大浏览器的网络请求中。

1.缓存处理，1.0中主要通过请求头中的If-Modified-Since,Expires来做为缓存判断的标准，而在1.1中则引入了更多的缓存控制策略如Enity tag，if-unmodified-since，if-match等更多可控制的缓存头来控制缓存策略。

2.网络链接使用的优化。在1.0中，很多用户请求的只是某个对象的一部分，服务器却将整个用户回传，并且不支持断电传输的功能，导致资源浪费，而在1.1中设置了range头域，它允许只请求资源的某个部分，及返回码为206。

3.错误通知的处理，在1.1中新添加了24个错误状态的响应码如409表示请求资源与资源当前的状态发生冲突，410表示某个资源并永久的删除。

4.在1.1中支持长连接和请求的流水线（pipelining）默认开启了connection:keep-alive，即一次tcp链接中可以处理多个请求，而在1.0中每一个请求就要开启一次tcp链接，十分浪费资源。

二、http2.0比http1.x的优化

1.新的二进制解析格式，http1.x中解析是基于文本的，而文本的表现形式多种多样，要做到健壮性必然要考虑很多东西，而二进制则只包括0和1，基于二进制解析的话方便且健壮。

2.多路复用（multiplexing）连接共享，即每一个requests都是用作链接共享机制的。一个request对应一个id，这样一个连接上有多个request，每个连接的request可以随机的混杂在一起，接收方根据他们的id将他们归属到不同的服务器端里面。即http2中多个请求可以在一个连接上并行执行。

3.header压缩，使用encoder来减少需要传输的header的大小。

> https://www.cnblogs.com/zllovellyo/p/12558741.html

## http总结


### 自己的总结

* http1.1 与http.0之间区别
	* 增加了更多的**缓存处理策略**
	* 网路链接中的优化，**支持返回部分资源**
	* 错误通知的处理，增加了**更多的错误返回码**
	* 默认开启**持久性连接**,即**一个TCP连接可以处理多个请求**

* http2.0与http1.1之间的区别
	* 新的二进制解析，抛弃了文本解析，更加健壮
	* 连接共享：http2中多个请求在一个连接上并行执行
	* header压缩

* http与https之间的区别
	* http在网络传输的时候是发送的明文，而https在网络传输的时候发送的加密的。
	* https = http+SSL（secure-sockest-layer）
		* https是一种通讯协议，是在http协议传输数据过程中，使用SSL/TSL（非对称加密模式）加密


### https
主要是在应用层和传输层之间加了一层SSL层。
更加具体的解析：https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA


## RSA（非对称加密）

* 公钥：是用来上锁的
* 私钥：是用来解锁的
* 通信过程：如果A和B想要通信，A就把公钥发给B，B每次把信息通过公钥加密后再发送给A，A再用私钥解密即可完成通信过程

## 家用的PPPoe协议

又叫做PPP over enthernet就是将PPP协议外层包上以太网协议

## 关于网络知识的常见面试题

* 三次握手
	* 客户端发送SYN=1, seq=x
	* 服务器端接收并发送SYN=1,ACK=1,seq=y,ack=x+1;
	* 客户端接收并发送ACK=1，seq=x+1,ack=y+1
	* 最终建立连接
	
* 四次挥手
	* 客户端发送FIN=1，seq=u(客户端进入终止等待1)
	* 服务器端接收并发送ACK=1,ack=u+1,seq=v(服务器端进入关闭等待状态)
	* 服务器端发送FIN=1,ack=u+1,seq=w(最后确认状态)
	* 客户端接收并发送ACK=1, ack=w+1;(客户端进入时间等待状态(TIME-WAIT))
	* 客户端经历2*MSL（最长报文段寿命时间后）关闭连接
	
* 为什么连接是三次握手，关闭的时候却是四次握手？
	
	* 建立连接的时候是用SYN来同步；关闭连接时server收到了FIN但是可能数据没有发送完
	
* 为什么TIME_WAIT状态需要经过2MSL（最大报文段生存时间）才能进入close状态
	
	* 因为四次挥手的最后一步是client端向server端发送ACK，但是有可能发送不到，所以等待server端的重传命令。
	
* 为什么不能用两次握手进行连接
	
	* 因为客户端不知道你到底有没有收到我发给你的信息
	
* 如果已经建立了连接，但是客户端突然出现故障怎么办？
	
	* 服务器端有一个定时器，计算客户端多久没有发送过来信息了，多次没有发送之后关闭连接。
	
* 四次挥手为什么不能改为三次？
  
  * https://www.cnblogs.com/Andya/p/7272462.html
  
  * 因为挥手的时候双方都要确认断开。
  
  * 而连接是双向的，三次握手中的第二次可以看作**一次确认**和**一次请求**，因为没有数据要传输所以可以放在一起，节省了一次。
  
    为什么是四次挥手而不是三次？
  
    因为服务端在接收到FIN, 往往不会立即返回FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。
  
    如果是三次挥手会有什么问题？
  
    等于说服务端将ACK和FIN的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。
  
    
  
    作者：砂壶
    链接：https://www.jianshu.com/p/573023a2e50c
    来源：简书
    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
  
* 为什么是四次挥手，而不是三次挥手？
  * 在建立连接的时候,Server把响应客户端的请求和请求客户端的确认放在一起发送给客户端了,即第二次握手时有SYN+ACK
  * 而断开连接的时候,一个方向的断开,只是说明该方向数据已传输完毕,而另一个方向或许还有数据,所以得等到另一个方向数据也全部传输完成后,才能执行第三次挥手
  
* tcp  udp主要特点等？

* tcp可靠性的原因？
	
	* 首先自己知道的第一个：确认机制，其实还有其他更多的机制待查


## IPv4中的保留地址
* 运营商用的内网IP：
	100.64.0.1
* 更多的保留的IP地址：
	https://wangye.org/blog/archives/1079/
* 所有的保留地址
	https://zh.wikipedia.org/wiki/%E4%BF%9D%E7%95%99IP%E5%9C%B0%E5%9D%80

## PPPoE

PPPoE（英语：Point-to-Point Protocol over Ethernet），以太网上的点对点协议，是将点对点协议（PPP）封装在以太网（Ethernet）框架中的一种网络隧道协议。由于协议中集成PPP协议，所以实现出传统以太网不能提供的身份验证、加密以及压缩等功能，也可用于缆线调制解调器（cable modem）和数位用户线路（DSL）等以以太网协议向用户提供接入服务的协议体系。 本质上，它是一个允许在以太网广播域中的两个以太网接口间创建点对点隧道的协议。

* 使用时的缺点
	* 使用Internet前，需先透过PPPoE进行拨接，而非电脑引导后立即上网。
	* 部分ISP会对PPPoE的连线用户采取定时断线，以节省营运成本及IP地址的占用，故对于需长时间挂网的用户较不利。但也有部分ISP为提供用户选择PPPoE可发配非固定IP或固定IP的服务。
	* 当前Windows XP之后的Windows，Mac OS X、Linux等操作系统等皆已内置PPPoE的拨接功能，更早期的操作系统需另行安装PPPoE的拨接程序，如Enternet 300、RAS PPPoE等。
* 在进行拨号的时候必须使用MAC地址进行交流。
> https://zh.wikipedia.org/wiki/PPPoE



传输层的功能：端到端的可靠的数据传输

设计协议：TCP/UDP协议

传输控制协议  transmission control protocol

用户数据报协议 user datagram protocol

传输层的功能：

端到端的数据传输

流量控制

​	流水线协议

​	一次性发送多个数据端

​	滑动窗口协议

已经ACK的，已经发送待ACK的，待发送的

接口端不需要有缓冲区，GBN受到一个之前的请求，已发送未ACK的全部重新发送



（GBN协议），

拥塞控制

​	拥塞控制的几个方法：

​	设置congWin = lastbitsend-lastbitack

​	慢启动

​	达到阈值之前每个RTT（最小往返时延）之后congwin翻倍，到达之后加性增

   

  加性增，乘性减

  到达阈值后，加性增加，乘性减小

  快速重传机制

 timeout事件和重复的ACKs

3个ACKS降为一班，timeout直接为1



连接控制



**差错检测??**

同步

绘画控制



## 网络层



功能：

寻址路由和转发（DNS）

协议：IP46/ICMP/ICMP/DHCP/NAT/RAP/RARP/路由（RIP，OSPF，BGP）

功能：




