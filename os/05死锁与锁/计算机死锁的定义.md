## 死锁的定义

	多个进程相互等待对方资源，在得到所有资源继续运行之前，都不会释放自己已有的资源，这样造成了循环等待的现象，称为死锁。

## 产生死锁的四大必要条件

	* 资源互斥/资源不共享
	* 占有并请求
	* 资源不可剥夺：资源别的线程已经占用
	* 环路等待：首位相连等待一个资源释放

（一）互斥条件：一个资源一次只能被一个进程访问。即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占 有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。

（二）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。

（三）不剥夺条件：进程已经获得的资源，在未使用完之前不能强行剥夺，而只能由该资源的占有者进程自行释放。

（四）循环等待条件：若干资源形成一种头尾相接的循环等待资源关系。

## 防止死锁的方法

**（每种方法都开销巨大，没有操作系统实现）**

1. 破坏互斥条件

	资源互斥是资源使用的固有特性是无法改变的，所以不可能避免

2. 破坏请求并保持条件

	方法：

		釆用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。

	缺点：

		系统资源被严重浪费，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。而且还会导致“饥饿”现象，当由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行。

3. 破坏不可剥夺条件

	方法：

		当一个已保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺了，或从而破坏了不可剥夺条件。

	缺点：

		该策略实现起来比较复杂，释放已获得的资源可能造成前一阶段工作的失效，反复地申请和释放资源会增加系统开销，降低系统吞吐量。这种方法常用于状态易于保存和恢复的资源，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源。

4. 破坏循环等待条件

	方法：

		为了破坏循环等待条件，可釆用顺序资源分配法。首先给系统中的资源编号，规定每个进程，必须按编号递增的顺序请求资源，同类资源一次申请完。也就是说，只要进程提出申请分配资源Ri，则该进程在以后的资源申请中，只能申请编号大于Ri的资源。

		采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。

	缺点：

		这种方法存在的问题是，编号必须相对稳定，这就限制了新类型设备的增加；尽管在为资源编号时已考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源的浪费；此外，这种按规定次序申请资源的方法，也必然会给用户的编程带来麻烦。

## 死锁避免算法

**由于无法防止死锁的发生，所以只能避免死锁的发生！**

1. 判断"系统安全状态"法

	在进行系统资源分配之前，先计算此次资源分配的安全性。
	若此次分配不会导致系统进入不安全状态，则将资源分配给进程； 否则，让进程等待。 

2. 银行家算法

	1、申请的贷款额度不能超过银行现有的资金总额（不能超额）

	2、分批次向银行提款，但是贷款额度不能超过一开始最大需求量的总额（分批发款）

	3、暂时不能满足客户申请的资金额度时，在有限时间内给予贷款（限时发款）

	4、客户要在规定的时间内还款（限时还款）

	操作系统按照银行家指定的规则为进程分配资源，当进程**首次申请资源时**，要测试该纪南城对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按照当前的申请量分配资源，否则就推迟分配。当进程在执行中**继续申请资源时**，先测试该进程本次申请的资源数是否超过了该资源所剩余的总量。若超过则拒绝分配资源，若能满足则按照当前的申请量分配资源，否则也要推迟分配。

## 死锁的检测

画出资源分配图，看看是否有循环占有和等待

> https://blog.csdn.net/jgm20475/article/details/81297819

## 关于死锁的例题

系统中有若干个互斥的资源R，6个并发的进程，每个进程都需要3个资源R，为使系统不发生死锁，至少需要多少个R：13个

解答：选择知C。死锁的发生是由于并发进程竞争资源而出现相互等待的现象。那么如果每个进程需要3个资源的话，即进程必须获得到3个资源才可以顺利的运行。当系统中发生极端的情况下，6个进程分别每个进程都获取到了2个资源，这时6个进程都无法继续运行，而处于等待状态，因为只有获取了5个资源才可以运行，那么就会等待其他进回程释放1个资源，而获取到该释放的资源，才可以凑齐到3个资源，得以运行。那么如果想保证不发生死锁的话，即只要在极端情况答下，再多增加一个资源，就可以打破死锁了。6X2+1=13.