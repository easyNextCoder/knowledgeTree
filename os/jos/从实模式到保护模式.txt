## 计算机启动过程：
1. bios自动将把硬盘中的第一个扇区读到0x7c00处，然后设置cs：ip = 0:7c00
2.  实模式跳转到保护模式

	设置好段描述符，全局段描述符寄存器，构造好段选择子-》
	设置保护模式的位寄存器，最后ljmp 段选择子：自己设置好的目标程序
	jmp之后已经由**物理地址**寻址转换为了**线性地址**寻址了。
<--
GDTR：全局描述符表寄存器-》存储描述符表的地址
	描述符表中存放的是：段描述符（64位）


实模式下的寻址：jmp cs:ip-》jmp  段基地址：段内偏移
保护模式下的寻址：jmp cs:ip-> jmp 段选择子：段内偏移
	但是应该首先建立好段描述符表，并将表的基地址载入到GDTR中；段选择子和段描	述符（64位）都是自己之前手动编写好的。然后jmp的时候，从段选择子中找索引	，指向对应的段描述符。(段选择子前13位表示索引，14位表示GDT或IDT，15-	16位表示特权级)
-->

3. 在保护模式下，将内核（内核是一个完整的可运行的ELF程序，存放在硬盘的第二个扇区及以后），按照读取到0x100000 1MB地址位置处，然后跳转到这里执行（进入.entry即可）。但是由于我们在连接编译和链接C程序的时候将C代码运行的虚拟地址设置为了KERNBASE所以这里要暂时开启分页（即由线性地址转换到虚拟地址模式下，分页表是我们之前首先手工写好的，并将表的地址放入页表基地址寄存器cr3处）；然后开启分页后的下一条语句就已经是运行在虚拟地址的状态了，然后再jmp一下跳到高地址位置。（这也是为什么写分页映射表的时候，0-4M和KERNBASE-KERNBASE+4M都要映射到通一个位置，否则开启分页后的下一句程序会崩溃）

最后设置sp和初始化bp(用于stack trace)正式跳入到C代码去执行。

1 2 3boot部分的使命已经结束，接下来进入到C语言来初始化的状态。

4. 进入C语言阶段后的第一件事是：内存初始化mem_init()

操作系统中的:text data bss 堆段 栈段的一般分布结构图是：
> https://my.oschina.net/pollybl1255/blog/140323/

mem_init:做的事情：
首先获得编译器编译完内核程序之后保存下来的bss段的最后位置地址，然后通过转换得到实际的物理地址，从这个物理地址之后的所有空间都是没有被利用的。
这个空间：
	首先头一部分先放置page table entry
	然后放page table 内容，除了IO映射的一部分，内核代码占据的一部分等（可能是多核入口占据的一部分），将所有的没有被使用的4G内存剩下的部分全部串联起来，串联到page_free_list上，这一部分就是page_init完成的功能。
	放完这两部分后，将这两部分映射到事前已经设计好的虚拟地址位置

	然后再放置envs(并且已经知道了系统所支持的最大的envs数目和env的结构)
	然后将这一部分映射到事前指定的虚拟地址位置。

	然后将内核栈映射到bootstack这个栈的大小是4KB

	然后将实地址0-KERNBASE映射到KERNBASE-0xffffffff（跟之前0-4M映射到KERNBASE-KERNBAS+4MB一样的道理，等于是重新映射了一遍，但是多了pages和env的操作）

	然后将kern_pgdir放入到cr3中重新进入到页模式

5. 接着开始env初始化在其他环境中其实是进程环境侧初始化

* env_init->负责将所有的env初始化并链接起来
	
	



寄存器包括：通用，指针，栈段，状态 共四类(看一下bp和sp的配合使用)
ax bx cx dx	si di(有时候也可以当做临时寄存器使用)
bp(用来和sp寄存器配合，实现函数调用返回等) sp ip
cs ds ss栈段寄存器(es拓展段寄存器 fs gs)
psw程序状态字

寄存器再分类：
通用寄存器：AX BX CX DX SI DI BP SP(都是32位)
段寄存器：CS DS ES SS GS（都是16位的，但是每二个段寄存器后面都有一个大于64位的段描述符寄存器自动装入）
状态标志 PSW
控制寄存器：CR0(PG|CD|NW|AM|WP|NE|ET|TS|EM|MP|PE) CR1（保留） CR2（页Fault线性地址） CR3（页目录基址寄存器...） CR4（MCE|PAE...）
GDTR 32位基址 16位限长
IDTR 与上相同
TR 16位描述符 32位线性地址 32位限长 其他属性
LDTR 16位描述符 描述符寄存器（透明装入）


ret 弹出ip （从ss:sp中）
iret 弹出ip cs flag（从ss:sp中）

	1.恢复IP(instruction pointer)：（IP）←（（SP）+1:（SP）），（SP）←（SP）+2
	2.恢复CS(code segment)：（CS）←（（SP）+1:（SP）），（SP）←（SP）+2
	3.恢复中断前的PSW(program status word),即恢复中断前的标志寄存器的状态。
	（FR）←（（SP）+1:（SP）），（SP）←（SP）+2

从实模式切换到保护模式的代码：

ldgt gdtdesc
movl %cr0, %eax
orl  $CR0_PE_ON, %eax
movl %eax, %cr0

ljmp $PROT_MODE_CSEG, $protcseg
