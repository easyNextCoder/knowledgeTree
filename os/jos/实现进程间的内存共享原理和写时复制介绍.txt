* 如何实现fork？
	首先fork（）是内核中的一个库函数，当用户调用fork的时候，首先调用的是lib/中的fork函数，
	fork函数中先调用系统函数sys_exofork()在调用这个函数后通过中断进入内核环境，进入中断之前当前环境的所有寄存器已经全部被保存,中断后进入内核环境，内核先生成一个用户环境env结构体，将当前的环境的结构体整个拷贝到新生成的env结构体中。（这部分的工作全部由内核完成）。这里有一点就是要将新设置环境中的eax寄存器设置为0，因为当新环境开始执行是就是从父亲环境进入中断的那一点开始重新执行的，设置eax=0就是设置整个中断的返回值，这样子进程的fork返回值就是0《总结就是从中断开始到中断结束中间都是内核态运行》

	当子环境生成的之后，开始env_run();由于env_run使用的iret来执行这个新环境的，而父进程的ip刚好指向exo_fork()的那个嵌入式中断，iret后，ip++刚好跳过再次的中断（子进程已经不需要再次中断申请子进程），于是eax中的值被当做返回值返回。至此fork的整个过程完成。

* 写实复制(COW技术）
	整个父进程的环境结构被复制给子环境，所以子环境中所有的page table中指向的页页都是与父环境相同，（**此时两个环境中的所有的内存都是共享的**）但是这些内容都是被父环境所占有的，我们只能读而不能做其他的事情，而且由于大多数我们申请完子进程之后就会将子进程加载其他的程序来运行，所以我们一般情况下没必要复制父环境中的page table中指向的页的内容，而只是要在往自己的指定位置写内容的时候出发页中断，再为自己申请内存将对应的父环境中的内存拷贝到相应的地址并奖励与父环境相同的映射。


* 进程之间进行内存共享的原理

	首先也要使用到IPC机制，未完

