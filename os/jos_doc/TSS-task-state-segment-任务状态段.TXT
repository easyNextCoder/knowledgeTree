1. linux进程切换和TSS结构
X86体系从硬件上支持任务间的切换。为此目的，它增设了一个新段：任务状态段(TSS)，它和数据段、代码段一样也是一种段，记录了任务的状态信息。

同其他段一样，TSS也有描述它的结构：TSS描述符表，它记录了一个TSS的信息，同时还有也给TR寄存器，它指向当前任务的TSS。任务切换的时候
，CPU会将原寄存器的内容写出到相应的TSS，同时将新TSS的内容填到寄存器中，这样就实现了任务的切换。

TSS在任务切换过程中起着重要作用，通过它实现任务的挂起和恢复。所谓任务切换是指挂起当前正在执行的任务，恢复或启动执行另一个任务。Linux
任务切换是通过switch_to这个宏来实现的。它利用长跳指令，当长跳指令的操作数是TSS描述符的时候，就会引起CPU的任务切换，此时，CPU将所有
寄存器的状态保存到当前任务寄存器TR所指向的TSS段中，然后利用长跳指令的操作数(TSS描述符)找到新任务的TSS段，并将其中的内容填写到各个寄存器
中，最后，**将新任务的TSS选择符更新到TR中**。这样系统就开始运行新切换的任务了。由此可见，通过在TSS中保存任务现场各寄存器状态的完整
映像，实现了任务的切换。task_struct中的tss成员就是记录TSS段内容的。当进程被切换前，该进程用tss_struct保存处理器的所有寄存器的当前值。
当进程重新执行时，CPU利用tss恢复寄存器状态。

2. x86体系下linux中的任务切换与TSS

Tss的作用举例：保存不同特权级别下任务所使用的寄存器，特别重要的是esp，因为比如中断后，涉及特权级切换时（一个任务切换），首先要切换栈
这个栈显然是内核栈，那么如何找到该栈的地址呢，这需要从tss段中得到，这样后续的执行才有所依托（在x86机器上，c语言的函数调用是通过栈实现的）
只要涉及低特权到高特权环的任务切换，都需要找到高特权环对应的栈，因此需要esp2, esp1,esp0起码三个esp，然而linux只使用esp0。

tss是什么：tss是一个段，段是x86的概念，在保护模式下，段选择符参与寻址，段选择符在段寄存器中，而tss段则在tr寄存器中
tr寄存器解析：https://blog.csdn.net/li4850729/article/details/7754647

intel的建议：为每个进程准备一个独立的tss段，进程切换的时候，切换tr寄存器使之指向该进程对应的tss段，然后在任务切换时（比如涉及特权级切换
的中断）使用该段保留所有的寄存器。

linux的做法：
1. linux没有为每个进程都准备一个tss段，而是每一个cpu使用一个tss段，tr寄存器保存该段。进程切换时，只要更新唯一tss段中的esp0字段到
新进程的内核栈。

2.linux的tss段中只使用esp0和iomap等字段，不用他来保存寄存器，在一个用户进程被中断进入ring0的时候，tss中取出esp0，然后切到esp0，其它
的寄存器则保存在esp0指示的内核栈上而不保存在tss中。（tr永远指向唯一的tss段，然而tss段中的esp0以及iomap却是不断随着进程切换而变化的。）
此时如果进程在用户态被中断，机器切到ring0，从tr中取出唯一的tss段，找到它的esp0，将堆栈切过去即可，然后把所有的其它寄存器都保存在tss当前的esp0指示的内核也就是ring0的堆栈上。


3.结果，linux中每一个cpu只有一个tss段，tr寄存器永远指向ta。符合x86处理器的使用规范，单不遵循intel的建议，这样的后果是开销更小了，因为不用
切换tr寄存器了。

https://blog.csdn.net/huangbin_online/article/details/9368373


