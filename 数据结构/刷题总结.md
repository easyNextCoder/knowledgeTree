

# 资源

[网址](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

# 排序

[排序总结](https://babyvector.github.io/blog/MD-sort-algorithm-tutorial.html)

## 拓扑排序

在AOV网中，若不存在回路，则所有活动可排列成一个线性序列，使得每个活动的所有前驱活动都排在该活动的前面，我们把此序列叫做拓扑序列(Topological order)，由AOV网构造拓扑序列的过程叫做拓扑排序(Topological sort)。AOV网的拓扑序列不是唯一的，满足上述定义的任一线性序列都称作它的拓扑序列。

# 指针

## 极值指针

#### [581. 最短无序连续子数组](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/)

## 双指针

* 双指针删除重复元素

  #### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

## 快慢指针

# 二分法

二分法一共三种写法

* 按照[left, right]进行处理

  ```java
  while(left<=right){
  	int mid = left+(right-left)/2;
  	if(arr[mid] == k){
  		return mid;	
  	}else if(arr[mid] > k){
  		right = mid-1;
  	}else{
  		left = mid+1;
  	}
  }
  ```

  能够对区间内的所有元素进行遍历

* 按照[left, right)进行处理

  ```java
  while(left<right){//等号没有意义
  	int mid = left+(right-left)/2;
  	if(arr[mid] == k){
  		return mid;
  	}else if(arr[mid]>k){
  		right = mid;
  	}else{
  		left = mid+1;
  	}
  }
  ```

  这里对right是无法遍历到的
  以上两种方法的[链接](https://blog.csdn.net/gongkeguo/article/details/123255001?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-123255001-blog-112527549.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-123255001-blog-112527549.pc_relevant_antiscanv2&utm_relevant_index=5)

* 划分红蓝区间进行处理

  ```java
  while(left+1<right){//保证一定能将整个数组划分位红蓝两个部分
  	int mid = left+(right-left)/2;//取下边界值
  	if(arr[mid] == k){
  		return mid;
  	}else if(arr[mid]>k){
  		right = mid;
  	}else{
  		left = mid;
  	}
  }
  ```

  [原文链接](https://www.bilibili.com/video/BV1d54y1q7k7?spm_id_from=333.880.my_history.page.click)

* 相关题目

  https://leetcode.cn/problems/nZZqjQ/submissions/

  https://leetcode.cn/problems/jJ0w9p/

  #### [29. 两数相除](https://leetcode.cn/problems/divide-two-integers/)

# 位运算

* 4字节int类型的最大值和最小值

* 正码、反码、补码（最大值，最小值的二进制）、4字节int越界问题
  [231. 2 的幂](https://leetcode.cn/problems/power-of-two/)

  #### [29. 两数相除](https://leetcode.cn/problems/divide-two-integers/)

# 树

## 前缀树

## 线段树

### 线段树定义

线段树（Segment Tree）是一种二叉树形数据结构，1977 年由 Jon Louis Bentley 发明，用以存储区间或线段，并且允许快速查询结构内包含某一点的所有区间。

一个包含 n 个区间的线段树，空间复杂度为 O(n)*O*(*n*)，查询的时间复杂度则为 O(log\ n+k)*O*(*l**o**g* *n*+*k*)，其中 k*k* 是符合条件的区间数量。

## 统计个数

#### [230. 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

这个是有两种方法的，两种方法自己都做了

### 相关题目

* #### [406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

  线段树 or 数组排序



# 堆

# 回溯

# 递归

# 动态规划



# 图

# 链表

# 贪心算法

# 位操作

# 分治

# 状态机

#### [剑指 Offer 20. 表示数值的字符串](https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)

**有时间去学习编译原理**

**有时间把自己的jos做完**







# 习题

### Leetcode题目

#### [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

双向链表+hashmap

#### [169. 多数元素](https://leetcode.cn/problems/majority-element/)

摩尔投票大乱斗

#### [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

深度或者广度优先搜索

时间复杂度O(MN)

#### [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

前缀树

#### [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

单调队列，deque，O(1)在任意时刻取出数组的最大值

ArrayList<Integer> -> int[]  <=> arr.stream().mapToInt(Integer::intValue).toArray();

#### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

默认的堆都是小顶堆

#### [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

二分查找和分治

#### [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

双指针

#### [287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

数组

#### [297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)

字符串处理、树的层序遍历

#### [338. 比特位计数](https://leetcode.cn/problems/counting-bits/)

位运算的优先符号，低于逻辑运算的符号

#### [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

堆，大顶堆和小顶堆，O(nlogk)前K大元素问题

#### [394. 字符串解码](https://leetcode.cn/problems/decode-string/)

栈

#### [990. 等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations/)

#### [399. 除法求值](https://leetcode.cn/problems/evaluate-division/)（带权重的并查集合）

并查集

* 并查集（不相交集合）用于处理**动态连通性**问题，最典型的应用是求几个最小生成树的Kruskal算法
* 并查集支持（1）查询find（2）合并union两个操作
* 并查集只回答两个节点是不是在一个联通分量中（也就是所谓的连通性问题），并不回答路径问题
* 如果一个问题具有传递性，可以考虑使用并查集
* 并查集最常见的一种设计思想是：把同在一个连通分量中的节点组织成一个树形结构

